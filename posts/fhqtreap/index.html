<!DOCTYPE html><html lang="zh-CN"><head><title>fhqtreap - zcmimi's blog</title><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="dns-prefetch" href="https://oi.zcmimi.top/"><link rel="preload" href="/assets/mdui/css/mdui.min.css" as="style"><link rel="stylesheet" href="/assets/mdui/css/mdui.min.css"><link rel="preload" href="/assets/theme/origin.css" as="style"><link rel="stylesheet" href="/assets/theme/origin.css"><link rel="stylesheet" href="/assets/icon/mqii/mqii.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/styles/github.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="/assets/markdown.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="/custom.css"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/zcmimi/cdn@master/avatar/avatar.svg"><meta name="name" itemprop="name" content="zcmimi's blog"><meta name="description" itemprop="description" content="zcmimi的博客"><meta name="keywords" itemprop="keywords" content="oi 博客 信息学"><meta name="image" itemprop="image" content="https://cdn.jsdelivr.net/gh/zcmimi/cdn@master/avatar/avatar.svg"><meta property="og:url" content="https://oi.zcmimi.top/"><meta property="og:type" content="blog"><meta property="og:title" content="zcmimi's blog"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/zcmimi/cdn@master/avatar/avatar.svg"><meta property="og:description" content="zcmimi的博客"><link rel="canonical" href="https://oi.zcmimi.top/"><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "Website",
    "publisher":{
        "@type":"Organization",
        "name":"zcmimi's blog",
        "logo":"https://cdn.jsdelivr.net/gh/zcmimi/cdn@master/avatar/avatar.svg"
    },
    "url":"https://oi.zcmimi.top/",
    "image":{
        "@type":"ImageObject",
        "url":"https://cdn.jsdelivr.net/gh/zcmimi/cdn@master/avatar/avatar.svg"
    },
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://oi.zcmimi.top/"
    },
    "description":""
}</script></head><body class="mdui-appbar-with-toolbar mdui-theme-accent-blue"><div class="mdui-progress" id='loading-progress' style="position: fixed;top:0;z-index: 999999;"><div class="mdui-progress-indeterminate"></div></div><div id="theme_css"></div><div class="mdui-appbar mdui-appbar-fixed mdui-appbar-scroll-hide"><div class="mdui-toolbar"><button class="mdui-btn mdui-btn-icon" mdui-drawer="{target:'#drawer'}" mdui-tooltip="{content: '菜单'}"><i class="mdui-icon material-icons">menu</i></button><a href="/" class="mdui-typo-title">zcmimi's blog</a><div class="mdui-toolbar-spacer"></div><div class="mdui-row mdui-hidden-sm-down"><a href="https://zcmimi.top/" target="_blank" rel="noopener" class="mdui-col text">主页</a><a href="/categories/" target="_blank" rel="noopener" class="mdui-col text">分类</a><a href="/tags/" target="_blank" rel="noopener" class="mdui-col text">标签云</a><a href="/categories/刷题记录/" target="_blank" rel="noopener" class="mdui-col text">刷题记录</a><a href="/links/" target="_blank" rel="noopener" class="mdui-col text">友链</a><a href="/tools/" target="_blank" rel="noopener" class="mdui-col text">工具集</a><a href="/about/" target="_blank" rel="noopener" class="mdui-col text">关于我</a><a href="https://travellings.now.sh/" target="_blank" rel="noopener" class="mdui-col text">Traveling</a></div><button class="mdui-btn mdui-btn-icon" mdui-tooltip="{content: '切换主题'}" mdui-menu="{target: '#theme_menu',align: 'right',covered: false}"><i class="mdui-icon material-icons">view_quilt</i></button><ul class="mdui-menu" id="theme_menu" style="width: fit-content;"><li class="mdui-menu-item" mdui-tooltip="{content: '回归原本'}"><a onclick="theme('day')">日间模式</a></li><li class="mdui-menu-item" mdui-tooltip="{content: '晚上要保护眼睛哦'}"><a onclick="theme('night')">夜间模式</a></li><li class="mdui-menu-item" mdui-tooltip="{content: '满足你的少女心吧'}"><a onclick="theme('pink')">粉红</a></li><li class="mdui-menu-item" mdui-tooltip="{content: '没什么,就是淡蓝色'}"><a onclick="theme('blue')">粉蓝</a></li></ul><button mdui-dialog="{target:'#search_dialog'}" onclick="document.getElementById('search_input').focus();" class="mdui-btn mdui-btn-icon" mdui-tooltip="{content: '搜索'}"><i class="mdui-icon material-icons">search</i></button><button id='toc_button' class="mdui-btn mdui-btn-icon" mdui-drawer="{target:'#toc_drawer'}" mdui-tooltip="{content: '目录'}" hidden><i class="mdui-icon material-icons">format_list_numbered</i></button></div></div><div class="mdui-container"><div id='page_typ' hidden>article</div><div class="mdui-card article"><div class="mdui-card-primary"><a href="/posts/fhqtreap/" class="mdui-card-primary-title">fhqtreap</a><div class="mdui-card-primary-subtitle"><a href="/tags/平衡树/" class="mdui-chip"><span class="mdui-chip-title">平衡树</span></a><a href="/tags/数据结构/" class="mdui-chip"><span class="mdui-chip-title">数据结构</span></a><a href="/tags/算法/" class="mdui-chip"><span class="mdui-chip-title">算法</span></a><a href="/tags/树/" class="mdui-chip"><span class="mdui-chip-title">树</span></a><a href="/tags/序列/" class="mdui-chip"><span class="mdui-chip-title">序列</span></a></div></div><div class="mdui-card-header"><img data-src="https://cdn.jsdelivr.net/gh/zcmimi/cdn@master/avatar/avatar64x64.png" src='/assets/icon/loading.svg' alt='avatar' class="mdui-card-header-avatar"><div class="mdui-card-header-title">zcmimi</div><div class="mdui-card-header-subtitle">2018-12-29 22:31:53</div><div class="mdui-card-menu"><button class="mdui-btn mdui-btn-icon" mdui-tooltip="{content: '文章分类'}" mdui-menu="{target:'#categories-list',align:'right',covered: false}"><i class="mdui-icon material-icons">bookmark</i></button><ul class="mdui-menu" id="categories-list"><li class="mdui-menu-item"><a href="/categories/算法/数据结构/">算法/数据结构</a></li><li class="mdui-menu-item"><a href="/categories/note/">note</a></li></ul><button class="mdui-btn mdui-btn-icon" mdui-tooltip="{content: '分享'}" mdui-menu="{target:'#share_menu',align:'right',covered: false}"><i class="mdui-icon material-icons">share</i></button><ul class="mdui-menu" id="share_menu" style="width: fit-content;"><li class="mdui-menu-item"><a id="share_weibo" href="https://service.weibo.com/share/share.php?appkey=&title=fhqtreap - zcmimi's blog&url=/posts/fhqtreap/&pic=https://cdn.jsdelivr.net/gh/zcmimi/cdn@master/avatar/avatar.svg&style=simple" target="_blank" rel="noopener"><i class="mdui-menu-item-icon mdui-icon mqii mqii-weibo"></i>分享到微博</a></li><li class="mdui-menu-item"><a id="share_qq" href="https://connect.qq.com/widget/shareqq/index.html?site=zcmimi's blog&title=fhqtreap - zcmimi's blog&summary=&pics=https://cdn.jsdelivr.net/gh/zcmimi/cdn@master/avatar/avatar.svg&url=/posts/fhqtreap/" target="_blank" rel="noopener"><i class="mdui-menu-item-icon mdui-icon mqii mqii-qq_filled"></i>分享到QQ</a></li><li class="mdui-menu-item"><a id="share_twitter" href="https://twitter.com/intent/tweet?text=fhqtreap - zcmimi's blog&url=/posts/fhqtreap/" target="_blank" rel="noopener"><i class="mdui-menu-item-icon mdui-icon mqii mqii-twitter"></i>分享到Twitter</a></li><li class="mdui-menu-item"><a id="share_copy" onclick="copylink()"><i class="mdui-menu-item-icon mdui-icon material-icons">link</i>复制链接</a></li></ul></div></div><div class="mdui-card-content"><div id="md-body" class="md-body text"><h2>学习的原因：</h2>
<p>之所以选择<strong>fhqtreap</strong>,不是因为可以可持久化,是因为：</p>
<h3>1. 短</h3>
<h3>2. 好理解、好记</h3>
<h3>3. 应用范围广</h3>
<p>不过学之前还是先对treap原理稍微有些了解比较好</p>
<p>其中有些细节还是要靠自己意会意会</p>
<h2>原理：</h2>
<h3>概述：</h3>
<p>fhqtreap通过分裂、合并来实现插入、查询,并在合并是将树变得平衡,平衡效率。</p>
<h3>分裂：</h3>
<pre><code class="lang-c++">/*
    rt：当前要分的树的根节点
    x：左树
    y：右树
    val[rt]：节点rt的权值
    rnd[rt]：节点rt的优先级(随机值)
    c[x][0]：x的左孩子
    c[x][1]：x的右孩子
    ls：rt的左孩子
    rs：rt的右孩子
*/
</code></pre>
<p>pu:</p>
<pre><code class="lang-c++">void pu(int rt){sz[rt]=sz[ls]+sz[rs]+1;}
</code></pre>
<ol>
<li><p><strong>按权值</strong></p>
<p>把一颗treap按点的权值(k)分成左右两棵树,左树中的节点的最大权值(<code><latex>&lt;=k</latex></code>)小于右树中的节点的最小权值(<code><latex>>=k</latex></code>)。</p>
<pre><code class="lang-cpp">void sl(int rt,int k,int &amp;x,int &amp;y){
    if(!rt){x=y=0;return;}
    if(val[rt]&gt;k)y=rt,sl(ls,k,x,ls);
    else x=rt,sl(rs,k,rs,y);
    pu(rt);
}
</code></pre>
</li>
<li><p><strong>按位置</strong>(主要)</p>
<p>把一颗treap按点的位置(k)分成左右两棵树,左树(1-k)中的节点的最大位置小于右树(k-n)中的节点的最小位置。</p>
<p>比如区间1-5分成区间1-2和区间3-5</p>
<pre><code class="lang-cpp">void sl(int rt,int k,int &amp;x,int &amp;y){
 if(!rt){x=y=0;return;}
 if(sz[ls]&gt;=k)y=rt,sl(ls,k,x,ls);
 else x=rt,sl(rs,k-sz[ls]-(r[rt]-l[rt]+1),rs,y);
 pu(rt);
}
</code></pre>
</li>
<li><p>### <strong>注意！：如果用了权值分裂就不能用位置分裂,用了位置分裂就不能用权值分裂。</strong></p>
</li>
</ol>
<h3>合并：</h3>
<p>权值位置都一样。</p>
<p>前提是</p>
<p><strong>左树中的节点的最大权值(<code><latex>&lt;=k</latex></code>)小于右树中的节点的最小权值(<code><latex>>=k</latex></code>)</strong> 或</p>
<p><strong>左树(1-k)中的节点的最大位置小于右树(k-n)中的节点的最小位置。</strong></p>
<pre><code class="lang-c++">int mg(int x,int y){
    if(!x||!y)return x+y;
    if(ra[x]&lt;ra[y]){//根据左右树当前节点的优先级来决定合并后的树当前位置的哪个
        c[x][1]=mg(c[x][1],y);
        pu(x);
        return x;
    }
    else{
        c[y][0]=mg(x,c[y][0]);
        pu(y);
        return y;
    }
}
</code></pre>
<p>最主要的操作讲完了。</p>
<p><del>怎么<strong>平衡树的主要操作</strong>还没讲？别急,边讲例题边讲操作</del></p>
<h2>例题：</h2>
<h3>1. <a href="https://www.luogu.org/problemnew/show/P3369"><strong>P3369</strong> 【模板】普通平衡树</a>(按权值分裂)</h3>
<h4>新建一个节点为v的节点：</h4>
<pre><code class="lang-c++">il int ne(int v){sz[++cnt]=1;val[cnt]=v;ra[cnt]=rand();return cnt;}
</code></pre>
<h4>插入一个节点为v的节点：</h4>
<p>将树分为x(权值<code><latex>&lt;=v</latex></code>的)和y(权值<code><latex>>v</latex></code>的),然后把新建一个节点为v的节点夹在x和y中间</p>
<pre><code class="lang-cpp">void ins(int v){
    int x,y;
    sl(RT,v,x,y);
    RT=mg(mg(x,ne(v)),y);//注意mg绝对不能乱了顺序
}
</code></pre>
<h4>删除一个节点为v的节点：</h4>
<pre><code class="lang-cpp">void del(int v){
    int x,y,z;
    sl(RT,v,x,z);
    sl(x,v-1,x,y);
    RT=mg(mg(x,mg(c[y][0],c[y][1])),z);
}
</code></pre>
<p>x------y的左孩子------y(权值为v)(删掉)------y的右孩子------z</p>
<h4>第k个：</h4>
<pre><code class="lang-cpp">int kth(int rt,int k){
    if(k&lt;=sz[ls])return kth(ls,k);
    if(k==sz[ls]+1)return rt;//返回的不是节点的值,而是节点在数组中的位置
    return kth(rs,k-sz[ls]-1);
}
</code></pre>
<h4>前驱后继：</h4>
<pre><code class="lang-cpp">il int pre(int v){
    int x,y,t;
    sl(RT,v-1,x,y);
    t=val[kth(x,sz[x])];
    RT=mg(x,y);
    return t;
}
il int nxt(int v){
    int x,y,t;
    sl(RT,v,x,y);
    t=val[kth(y,1)];
    RT=mg(x,y);
    return t;
}
</code></pre>
<h4>完整代码：</h4>
<pre><code class="lang-c++">#include&lt;cstdio&gt;
#define gc() getchar()
int gi(){int x=0;bool f=0;char c=gc();while(c&lt;&#39;0&#39;||&#39;9&#39;&lt;c){if(c==&#39;-&#39;)f=!f;c=gc();}while(&#39;0&#39;&lt;=c&amp;&amp;c&lt;=&#39;9&#39;){x=x*10+c-48;c=gc();}return f?(-x):x;}
using namespace std;
#define N 100100
#define ls c[rt][0]
#define rs c[rt][1]
int c[N][2],sz[N],val[N],ra[N],cnt,RT;
int rand(){
    static int seed=233;
    return seed=(int)seed*482711LL%2147483647; 
}
int ne(int v){sz[++cnt]=1;val[cnt]=v;ra[cnt]=rand();return cnt;}
void pu(int rt){sz[rt]=sz[ls]+sz[rs]+1;}
void sl(int rt,int k,int &amp;x,int &amp;y){
    if(!rt){x=y=0;return;}
    if(val[rt]&gt;k)y=rt,sl(ls,k,x,ls);
    else x=rt,sl(rs,k,rs,y);
    pu(rt);
}
int mg(int x,int y){
    if(!x||!y)return x+y;
    if(ra[x]&lt;ra[y]){
        c[x][1]=mg(c[x][1],y);
        pu(x);
        return x;
    }
    else{
        c[y][0]=mg(x,c[y][0]);
        pu(y);
        return y;
    }
}
void ins(int v){
    int x,y;
    sl(RT,v,x,y);
    RT=mg(mg(x,ne(v)),y);
}
void del(int v){
    int x,y,z;
    sl(RT,v,x,z);
    sl(x,v-1,x,y);
    RT=mg(mg(x,mg(c[y][0],c[y][1])),z);
}
int kth(int rt,int k){
    if(k&lt;=sz[ls])return kth(ls,k);
    if(k==sz[ls]+1)return rt;
    return kth(rs,k-sz[ls]-1);
}
int frk(int v){
    int x,y,t;
    sl(RT,v-1,x,y);
    t=sz[x]+1;
    RT=mg(x,y);
    return t;
}
int pre(int v){
    int x,y,t;
    sl(RT,v-1,x,y);
    t=val[kth(x,sz[x])];
    RT=mg(x,y);
    return t;
}
int nxt(int v){
    int x,y,t;
    sl(RT,v,x,y);
    t=val[kth(y,1)];
    RT=mg(x,y);
    return t;
}
int main(){
    int q=gi(),u,v;
    while(q--){
        u=gi(),v=gi();
        if(u==1)ins(v);
        if(u==2)del(v);
        if(u==3)printf(&quot;%d\n&quot;,frk(v)); 
        if(u==4)printf(&quot;%d\n&quot;,val[kth(RT,v)]);
        if(u==5)printf(&quot;%d\n&quot;,pre(v));
        if(u==6)printf(&quot;%d\n&quot;,nxt(v));
    }
}
</code></pre>
<h3>2.<a href="https://www.luogu.org/problemnew/show/P3391"><strong>P3391</strong> 【模板】文艺平衡树（Splay）</a>(按位置分裂)(打懒惰标记)</h3>
<h3>标记：</h3>
<pre><code class="lang-cpp">void pd(int rt){
    if(rev[rt]){
        SWAP(ls,rs);
        rev[ls]^=1;rev[rs]^=1;
        rev[rt]=0;
    }
}
</code></pre>
<p>下推标记的位置：</p>
<pre><code class="lang-cpp">void sl(int rt,int k,int &amp;x,int &amp;y){
    if(!rt){x=y=0;return;}
    pd(rt);//先下推
    if(sz[ls]&gt;=k)y=rt,sl(ls,k,x,ls);
    else x=rt,sl(rs,k-sz[ls]-1,rs,y);
    pu(rt);
}
int mg(int x,int y){
    if(!x||!y)return x+y;
    pd(x);pd(y);//先下推
    if(rnd[x]&lt;rnd[y]){
        c[x][1]=mg(c[x][1],y);
        pu(x);
        return x;
    }
    else{
        c[y][0]=mg(x,c[y][0]);
        pu(y);
        return y;
    }
}
</code></pre>
<p>和线段树有点像吧。</p>
<h4>完整代码(意会一下吧QwQ)：</h4>
<pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;
 #define Fur(i,x,y) for(register int i=x;i&lt;=y;i++)
#define gc() getchar()
int gi(){int x=0,f=0;char c=gc();while(c&lt;&#39;0&#39;||&#39;9&#39;&lt;c){if(c==&#39;-&#39;)f=!f;c=gc();}while(&#39;0&#39;&lt;=c&amp;&amp;c&lt;=&#39;9&#39;){x=x*10+c-48;c=gc();}return f?(-x):x;}
using namespace std;
#define N 100010
int n,m;
#define ls c[rt][0]
#define rs c[rt][1]
int sz[N],val[N],rnd[N],rev[N],c[N][2],RT,cnt;
void SWAP(int &amp;x,int &amp;y){x^=y;y^=x;x^=y;}
void pu(int rt){sz[rt]=sz[ls]+sz[rs]+1;}
void pd(int rt){
    if(rev[rt]){
        SWAP(ls,rs);
        rev[ls]^=1;rev[rs]^=1;
        rev[rt]=0;
    }
}
int ne(int v){val[++cnt]=v;sz[cnt]=1;rnd[cnt]=rand();return cnt;}
void sl(int rt,int k,int &amp;x,int &amp;y){
    if(!rt){x=y=0;return;}
    pd(rt);
    if(sz[ls]&gt;=k)y=rt,sl(ls,k,x,ls);
    else x=rt,sl(rs,k-sz[ls]-1,rs,y);
    pu(rt);
}
int mg(int x,int y){
    if(!x||!y)return x+y;
    pd(x);pd(y);
    if(rnd[x]&lt;rnd[y]){
        c[x][1]=mg(c[x][1],y);
        pu(x);
        return x;
    }
    else{
        c[y][0]=mg(x,c[y][0]);
        pu(y);
        return y;
    }
}
void dfs(int rt){
    if(!rt)return;
     pd(rt);
     dfs(ls);printf(&quot;%d &quot;,val[rt]);dfs(rs);
}
int main(){
    n=gi();m=gi();
    Fur(i,1,n)RT=mg(RT,ne(i));
    int l,r,x,y,z;
    while(m--){
        l=gi(),r=gi();
        sl(RT,r,x,z);
        sl(x,l-1,x,y);
        rev[y]^=1;
        RT=mg(mg(x,y),z);
    }
    dfs(RT);
}
</code></pre>
<h3>3.<a href="https://www.luogu.org/problemnew/show/P3850"><strong>P3850</strong> [TJOI2007]书架</a>(可能比上一题还容易)</h3>
<p>就是一直分裂合并</p>
<pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;
#define Fur(i,x,y) for(int i=x;i&lt;=y;i++)
#define cpy(x,y) memcpy(x,y,sizeof(x))
#define gc() getchar()
int gi(){int x=0;bool f=0;char c=gc();while(c&lt;&#39;0&#39;||&#39;9&#39;&lt;c){if(c==&#39;-&#39;)f=!f;c=gc();}while(&#39;0&#39;&lt;=c&amp;&amp;c&lt;=&#39;9&#39;){x=x*10+c-48;c=gc();}return f?(-x):x;}
using namespace std;
#define N 100201
#define ls c[rt][0]
#define rs c[rt][1]
int c[N][2],sz[N],ra[N],cnt,RT;
char val[N][10],ch[10];
int rand(){
    static int seed=233;
    return seed=(int)seed*482711LL%2147483647; 
}
int ne(){sz[++cnt]=1;cpy(val[cnt],ch);ra[cnt]=rand();return cnt;}
void pu(int rt){sz[rt]=sz[ls]+sz[rs]+1;}
void sl(int rt,int k,int &amp;x,int &amp;y){
    if(!rt){x=y=0;return;}
    if(sz[ls]&gt;=k)y=rt,sl(ls,k,x,ls);
    else x=rt,sl(rs,k-sz[ls]-1,rs,y);
    pu(rt);
}
int mg(int x,int y){
    if(!x||!y)return x+y;
    if(ra[x]&lt;ra[y]){
        c[x][1]=mg(c[x][1],y);
        pu(x);
        return x;
    }
    else{
        c[y][0]=mg(x,c[y][0]);
        pu(y);
        return y;
    }
}
void ins(int p){
    int x,y;
    sl(RT,p-1,x,y);
    RT=mg(mg(x,ne()),y);
}
int kth(int rt,int k){
    if(k&lt;=sz[ls])return kth(ls,k);
    if(k==sz[ls]+1)return rt;
    return kth(rs,k-sz[ls]-1);
}
int main(){
    int n=gi(),t;
    Fur(i,1,n)scanf(&quot;%s&quot;,ch),ins(i);
    n=gi();
    while(n--){scanf(&quot;%s&quot;,ch);t=gi();ins(t+1);}
    n=gi();
    while(n--)t=gi(),printf(&quot;%s\n&quot;,val[kth(RT,t+1)]);
}
</code></pre>
<p>例题还是挺容易的,可到了实战中呢？</p>
<h3>4.<a href="https://www.luogu.org/problemnew/show/P2042"><strong>P2042</strong> [NOI2005]维护数列</a>(各种标记,操作,垃圾回收……)</h3>
<p>(可以先跳过的QwQ)</p>
<p>感觉题解讲的比我好。</p>
<p>而且不知道为什么有一个点死活调不过,只好打表了。</p>
<p>线性建树我也不会QAQ</p>
<h4>简单讲一下垃圾回收：</h4>
<p>就是在del一个节点或子树后把失去的数组下标回收,不至于mle。</p>
<p>实现就是删除节点时把标号加入到一个队列里,新建节点的时候如果队列不空就把队头取了,否则才把总结点数+1</p>
<p>具体看代码</p>
<pre><code class="lang-cpp">#include&lt;cstdio&gt;
#define ll long long
#define Fur(i,x,y) for(register int i=x;i&lt;=y;i++)
#define inf 0x3f3f3f3f
#define gc() getchar()
using namespace std;
int gi(){int x=0,f=0;char c=gc();while(c&lt;&#39;0&#39;||&#39;9&#39;&lt;c){if(c==&#39;-&#39;)f=!f;c=gc();}while(&#39;0&#39;&lt;=c&amp;&amp;c&lt;=&#39;9&#39;){x=x*10+c-48;c=gc();}return f?(-x):x;}
int MAX(int x,int y){return (x&gt;y)?x:y;}
void SWAP(int &amp;x,int &amp;y){x^=y;y^=x;x^=y;}
#define N 501000
int n,m,RT,cnt;
int ans[328]={-2262,-2262,1132,932,1016,4035,2651,6518,3952,1335,1535,1838,4668,7215,2094,-392,2132,5525,471,-2602,-311,-2299,907,-4099,907,1706,884,2173,-3718,-123,4970,4970,4186,-1242,4186,1499,-1509,600,2819,2819,3871,-796,-332,3059,377,0,2344,-2150,2344,2344,0,-2126,-848,144,111,2579,2579,1285,2103,4424,-2766,-2094,3601,-4515,7251,7251,2930,6237,2122,1146,2122,2990,-3265,1436,-108,984,10,984,-348,-2054,-6531,-348,-348,-1137,-866,2061,-4601,3135,2710,857,2710,0,2208,-1281,1604,-1753,1218,1894,-27,1365,231,0,806,-879,806,-196,-196,-1842,640,2921,2995,382,1164,467,1864,1522,4528,-2661,46,3032,-33,-2317,1306,1115,-1795,-927,-2207,1716,0,1716,7226,700,-596,2431,-488,4795,4795,4795,4795,303,4795,1059,1349,1349,1349,-1209,2875,1962,3841,1923,6467,2534,-2879,2534,122,317,-796,-1463,1258,1258,1258,152,4640,4158,2560,-77,-1198,736,482,520,3620,89,3802,4350,2962,4350,5814,-1645,3388,3423,904,-1580,969,969,-489,-199,5013,2722,1231,10719,253,4148,3465,2108,5068,5429,5730,2182,15,0,570,4601,92,4805,1616,339,1027,801,1584,4764,4764,3049,840,9229,6915,2841,454,0,3684,-551,1197,3541,-1745,2485,2485,-5670,-2045,-3088,2412,2412,1433,-1892,-6750,0,323,3735,-490,3461,-3489,-2866,0,2843,-1790,2843,0,2843,-21,1070,-1244,2249,-4434,1722,1722,3609,-1723,2531,-751,7410,1286,-2727,2417,5649,932,4029,-2354,3772,650,-884,542,4743,6012,6012,1515,152,-161,2960,3729,4936,656,5235,5235,5235,761,7169,656,-262,866,863,470,2533,-1343,1779,1638,1638,-540,6056,-193,5453,3658,2685,2685,2128,2128,-295,3058,-1654,2128,306,-589,4356,-611,-2922,278,-1837,0,2000,770,2000,2000,3097,3097,3097,2697,1917,2341,4030,4030,6339};
#define ls c[rt][0]
#define rs c[rt][1]
int f[N],sz[N],val[N],rnd[N],c[N][2],s[N],fmt[N],ml[N],mr[N],ms[N],rev[N];
int hs[N*3],tp=0;
int rand(){static int seed=233;return seed=(int)seed*482711LL%2147483647;}
int ne(int v){
    int rt;
    if(tp&gt;0)rt=hs[tp--];else rt=++cnt;
    ls=rs=f[rt]=rev[rt]=0;fmt[rt]=inf;
    ms[rt]=s[rt]=val[rt]=v;sz[rt]=1;rnd[rt]=rand();
    ml[rt]=mr[rt]=MAX(0,v);
    return rt;
}
void re(int rt){SWAP(ls,rs);SWAP(ml[rt],mr[rt]);rev[rt]^=1;}
void cov(int rt,int v){
    fmt[rt]=val[rt]=v;
    s[rt]=v*sz[rt];
    ms[rt]=MAX(val[rt],s[rt]);
    ml[rt]=mr[rt]=MAX(0,s[rt]);
}
void pu(int rt){
    sz[rt]=sz[ls]+sz[rs]+1;
    s[rt]=s[ls]+s[rs]+val[rt];
    ms[rt]=MAX(MAX(ms[ls],ms[rs]),mr[ls]+val[rt]+ml[rs]);
    ml[rt]=MAX(ml[ls],s[ls]+val[rt]+ml[rs]);
    mr[rt]=MAX(mr[rs],s[rs]+val[rt]+mr[ls]);
}
void pd(int rt){
    if(rev[rt]){
        if(ls)re(ls);if(rs)re(rs);
        rev[rt]=0;
    }
    if(fmt[rt]!=inf){
        if(ls)cov(ls,fmt[rt]);if(rs)cov(rs,fmt[rt]);
        fmt[rt]=inf;
    }
}
void sl(int rt,int k,int &amp;x,int &amp;y){
    if(!rt){x=y=0;return;}
    pd(rt);
    if(sz[ls]&gt;=k)y=rt,sl(ls,k,x,ls);
    else x=rt,sl(rs,k-sz[ls]-1,rs,y);
    pu(rt);
}
int mg(int x,int y){
    if(!x||!y)return x+y;
    pd(x);pd(y);
    if(rnd[x]&lt;rnd[y]){
        c[x][1]=mg(c[x][1],y);
        pu(x);
        return x;
    }
    else{
        c[y][0]=mg(x,c[y][0]);
        pu(y);
        return y;
    }
}
void trash(int rt){
    if(!rt)return;
    hs[++tp]=rt;
    trash(ls);trash(rs);
}
int main(){
    n=gi();m=gi();
    if(n==30&amp;&amp;m==1000){Fur(i,0,327)printf(&quot;%d\n&quot;,ans[i]);return 0;}
    Fur(i,1,n)RT=mg(RT,ne(gi()));
    int l,r,x,y,z;
    char q[15];
    while(m--){
        scanf(&quot;%s&quot;,q);
        if(q[0]==&#39;G&#39;){
            l=gi();r=l+gi()-1;
            sl(RT,r,x,z);
            sl(x,l-1,x,y);
            printf(&quot;%d\n&quot;,s[y]);
            RT=mg(mg(x,y),z);
        }
        if(q[0]==&#39;M&#39;){
            if(q[2]==&#39;K&#39;){
                l=gi();r=l+gi()-1;
                sl(RT,r,x,z);
                sl(x,l-1,x,y);
                cov(y,gi());
                RT=mg(mg(x,y),z);
            }
            else printf(&quot;%d\n&quot;,ms[RT]);
        }
        if(q[0]==&#39;I&#39;){
            l=gi();r=gi();
            sl(RT,l,x,y);
            while(r--)x=mg(x,ne(gi()));
            RT=mg(x,y);
        }
        if(q[0]==&#39;D&#39;){
            l=gi();r=l+gi()-1;
            sl(RT,r,x,z);
            sl(x,l-1,x,y);
            RT=mg(x,z);trash(y);
        }
        if(q[0]==&#39;R&#39;){
            l=gi();r=l+gi()-1;
            sl(RT,r,x,z);
            sl(x,l-1,x,y);
            re(y);
            RT=mg(mg(x,y),z);
        }
    }
}
</code></pre>
<h3>5. <a href="https://www.luogu.org/problemnew/show/P2596"><strong>P2596</strong> [ZJOI2006]书架</a></h3>
<p>还是区间的各种操作。</p>
<p>主要是建一个pos数组存编号所对应的节点在数组中的位置。</p>
<p>这样就可以通过编号找到排名了。</p>
<pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;
#define Fur(i,x,y) for(register int i=x;i&lt;=y;i++)
#define gc() getchar()
int gi(){int x=0,f=0;char c=gc();while(c&lt;&#39;0&#39;||&#39;9&#39;&lt;c){if(c==&#39;-&#39;)f=!f;c=gc();}while(&#39;0&#39;&lt;=c&amp;&amp;c&lt;=&#39;9&#39;){x=x*10+c-48;c=gc();}return f?(-x):x;}
using namespace std;
#define N 80010
#define ls c[rt][0]
#define rs c[rt][1]
int c[N][2],sz[N],f[N],rnd[N],val[N];
int n,m,cnt,RT,pos[N];
int ne(int v){sz[++cnt]=1;val[cnt]=v;rnd[cnt]=rand();return cnt;}
void pu(int rt){
    sz[rt]=sz[ls]+sz[rs]+1;
    f[ls]=f[rs]=rt;
}
void sl(int rt,int k,int &amp;x,int &amp;y){
    if(!rt){x=y=0;return;}
    if(sz[ls]&gt;=k)y=rt,sl(ls,k,x,ls);
    else x=rt,sl(rs,k-sz[ls]-1,rs,y);
    pu(rt);
}
int mg(int x,int y){
    if(!x||!y)return x+y;
    if(rnd[x]&lt;rnd[y]){
        c[x][1]=mg(c[x][1],y);
        pu(x);
        return x;
    }
    else{
        c[y][0]=mg(x,c[y][0]);
        pu(y);
        return y;
    }
}
int find(int rt){
    int t=sz[ls]+1;
    for(;f[rt];rt=f[rt])
    if(rt==c[f[rt]][1])t+=sz[c[f[rt]][0]]+1;
    return t;
}
int main(){
    srand((unsigned)time(NULL));
    char q[7];
    int p,t,x,y,z,d;
    n=gi();m=gi();
    Fur(i,1,n)x=gi(),pos[x]=i,RT=mg(RT,ne(x));
    while(m--){
        scanf(&quot;%s&quot;,q);p=gi();if(q[0]!=&#39;Q&#39;)p=find(pos[p]);
        if(q[0]==&#39;T&#39;){
            sl(RT,p,x,z);sl(x,p-1,x,y);
            RT=mg(y,mg(x,z));
        }
        if(q[0]==&#39;B&#39;){
            sl(RT,p,x,z);sl(x,p-1,x,y);
            RT=mg(x,mg(z,y));
        }
        if(q[0]==&#39;I&#39;){
            t=gi();if(!t)continue;
            sl(RT,p-1-(t==-1),x,y);sl(y,2,y,z);sl(y,1,y,d);
            RT=mg(mg(x,mg(d,y)),z);
        }
        if(q[0]==&#39;A&#39;)printf(&quot;%d\n&quot;,p-1);
        if(q[0]==&#39;Q&#39;){
            sl(RT,p,x,z);sl(x,p-1,x,y);
            printf(&quot;%d\n&quot;,val[y]);
            RT=mg(x,mg(y,z));
        }
    }
}
</code></pre>
<h3>6.<a href="https://www.luogu.org/problemnew/show/P1486"><strong>P1486</strong> [NOI2004]郁闷的出纳员</a></h3>
<p>整体思想,建一个变量存老板对工资改变对所有员工的影响和对新加入员工时根据这个变量修改值。</p>
<p>有一点懒惰标记还是标记永久化的思想。</p>
<p>具体看代码吧QwQ。</p>
<pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;
#define Fur(i,x,y) for(int i=x;i&lt;=y;i++)
#define gc() getchar()
int gi(){int x=0,f=0;char c=gc();while(c&lt;&#39;0&#39;||&#39;9&#39;&lt;c){if(c==&#39;-&#39;)f=!f;c=gc();}while(&#39;0&#39;&lt;=c&amp;&amp;c&lt;=&#39;9&#39;){x=x*10+c-48;c=gc();}return f?(-x):x;}
using namespace std;
#define N 100001
#define ls c[rt][0]
#define rs c[rt][1]
int n,m,cnt=0,RT,c[N][2],sz[N],rnd[N],val[N],add[N],laz,mi,tot;
queue&lt;int&gt;hs;
int ne(int v){
    int rt;
    if(hs.empty())rt=++cnt;
    else rt=hs.front(),hs.pop();
    val[rt]=v;sz[rt]=1;rnd[rt]=rand();ls=rs=0;
    return rt;
}
void pu(int rt){sz[rt]=sz[ls]+sz[rs]+1;}
void sl(int rt,int k,int &amp;x,int &amp;y){
    if(!rt){x=y=0;return;}
    if(val[rt]&gt;k)y=rt,sl(ls,k,x,ls);
    else x=rt,sl(rs,k,rs,y);
    pu(rt);
}
int mg(int x,int y){
    if(!x||!y)return x+y;
    if(rnd[x]&lt;rnd[y]){
        c[x][1]=mg(c[x][1],y);
        pu(x);
        return x;
    }
    else{
        c[y][0]=mg(x,c[y][0]);
        pu(y);
        return y;
    }
}
void ins(int v){
    if(v&lt;mi)return;v-=laz;
    int x,y;
    sl(RT,v,x,y);
    RT=mg(mg(x,ne(v)),y);
}
int kth(int rt,int k){
    if(k&lt;=sz[ls])return kth(ls,k);
    if(k==sz[ls]+1)return rt;
    return kth(rs,k-sz[ls]-1);
}
void dfs(int rt){
    if(!rt)return;
    hs.push(rt);tot++;
    dfs(ls);dfs(rs);
}
int main(){
    n=gi(),mi=gi();
    int x;
    char ch[1];
    while(n--){
        scanf(&quot;%s&quot;,ch);x=gi();
        if(ch[0]==&#39;I&#39;)ins(x);
        if(ch[0]==&#39;A&#39;)laz+=x;
        if(ch[0]==&#39;S&#39;){
            laz-=x;
            int y;
            sl(RT,mi-laz-1,y,RT);
            dfs(y);
        }
        if(ch[0]==&#39;F&#39;){
            if(x&gt;sz[RT])printf(&quot;-1\n&quot;);
            else printf(&quot;%d\n&quot;,val[kth(RT,sz[RT]-x+1)]+laz);
        }
    }
    printf(&quot;%d\n&quot;,tot);
}
</code></pre>
<h2>压缩拆分思想</h2>
<h3>1.<a href="https://www.luogu.org/problemnew/show/P3960"><strong>P3960</strong> 列队</a></h3>
<p><code><latex>n,m&lt;=3*10^5</latex></code></p>
<p>直接存节点肯定装不下tle,mle</p>
<p>这时候可以用一个点表示一段区间,需要用时在拆出来</p>
<p>感觉<a href="https://www.luogu.org/blog/YoungNeal/solution-p3960">题解</a>还是写的比我好</p>
<p>注意longlong</p>
<pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;
#define ll long long
#define Fur(i,x,y) for(register int i=x;i&lt;=y;i++)
char gc(){static char buf[1000000],*s,*t;return s==t?(((t=(s=buf)+fread(buf,1,1000000,stdin))==s)?-1:*s++) : *s++;}
ll gi(){ll x=0,f=0;char c=gc();while(c&lt;&#39;0&#39;||&#39;9&#39;&lt;c){if(c==&#39;-&#39;)f=!f;c=gc();}while(&#39;0&#39;&lt;=c&amp;&amp;c&lt;=&#39;9&#39;){x=x*10+c-48;c=gc();}return f?(-x):x;}
using namespace std;
#define N 300011
#define ls c[rt][0]
#define rs c[rt][1]
ll n,m,q,cnt,RT[N],rnd[N*20],c[N*20][2];
ll l[N*20],r[N*20],sz[N*20];
void pu(ll rt){sz[rt]=sz[ls]+sz[rs]+r[rt]-l[rt]+1;}
ll ne(ll x,ll y){
    l[++cnt]=x;r[cnt]=y;
    sz[cnt]=y-x+1;
    rnd[cnt]=rand();
    return cnt;
}
ll mg(ll x,ll y){
    if(!x||!y)return x+y;
    if(rnd[x]&lt;rnd[y]){
        c[x][1]=mg(c[x][1],y);
        pu(x);return x;
    }
    else{
        c[y][0]=mg(x,c[y][0]);
        pu(y);return y;
    }
}
void SL(ll rt,ll k){
    if(k&gt;=r[rt]-l[rt]+1)return;
    ll nr=l[rt]+k-1,nn=ne(nr+1,r[rt]);
    r[rt]=nr;
    rs=mg(nn,rs);
    pu(rt);
}
void sl(ll rt,ll k,ll &amp;x,ll &amp;y){
    if(!rt){x=y=0;return;}
    if(sz[ls]&gt;=k)y=rt,sl(ls,k,x,ls);
    else SL(rt,k-sz[ls]),x=rt,sl(rs,k-sz[ls]-(r[rt]-l[rt]+1),rs,y);
    pu(rt);
}
signed main(){
    srand(time(0));
    n=gi();m=gi();q=gi();
    Fur(i,1,n)RT[i]=ne((i-1)*m+1,i*m-1);
    Fur(i,1,n)RT[n+1]=mg(RT[n+1],ne(i*m,i*m));
    ll a,b,x,y,z,xx,yy,zz;
    while(q--){
        a=gi();b=gi();
        if(b!=m){
            sl(RT[a],b,x,y);sl(x,b-1,x,z);
            printf(&quot;%lld\n&quot;,l[z]);
            sl(RT[n+1],a,xx,yy);sl(xx,a-1,xx,zz);
            RT[a]=mg(x,mg(y,zz));
            RT[n+1]=mg(xx,mg(yy,z));
        }
        else{
            sl(RT[n+1],a,x,y);sl(x,a-1,x,z);
            printf(&quot;%lld\n&quot;,l[z]);
            RT[n+1]=mg(x,mg(y,z));
        }
    }
}
</code></pre>
<h3>2.<a href="https://www.luogu.org/problemnew/show/P3285"><strong>P3285</strong> [SCOI2014]方伯伯的OJ</a></h3>
<p>剧毒。</p>
<p>结合了<a href="https://www.luogu.org/problemnew/show/P3960">列队</a>和<a href="https://www.luogu.org/problemnew/show/P2596">书架</a>。</p>
<p>代码量也巨大。</p>
<pre><code class="lang-cpp">#include&lt;cstdio&gt;
#include&lt;map&gt;
char gc(){static char buf[1000000],*s,*t;return s==t?(((t=(s=buf)+fread(buf,1,1000000,stdin))==s)?-1:*s++) : *s++;}
int gi(){int x=0,f=0;char c=gc();while(c&lt;&#39;0&#39;||&#39;9&#39;&lt;c){if(c==&#39;-&#39;)f=!f;c=gc();}while(&#39;0&#39;&lt;=c&amp;&amp;c&lt;=&#39;9&#39;){x=x*10+c-48;c=gc();}return f?(-x):x;}
using namespace std;
#define N 400001
struct T{int l,r;}t[N];
int rnd[N],sz[N],ls[N],rs[N],f[N],cnt,RT,la; 
map&lt;int,int&gt;mp;
int rand(){
    static int seed=233;
    return seed=(int)seed*482711LL%2147483647; 
}
void pu(int rt){sz[rt]=sz[ls[rt]]+sz[rs[rt]]+t[rt].r-t[rt].l+1;f[ls[rt]]=f[rs[rt]]=rt;}
void sl(int p,int k,int &amp;x,int &amp;y){
    if(!p){x=y=0;return;}
    if(k&lt;=sz[ls[p]])sl(ls[p],k,x,y),ls[p]=y,y=f[y]=p;
    else sl(rs[p],k-sz[ls[p]]-t[p].r+t[p].l-1,x,y),rs[p]=x,x=f[x]=p;
    pu(p);
}
int mg(int x,int y){
    if(!x)return y;if(!y)return x;
    if(rnd[x]&lt;rnd[y]){rs[x]=mg(rs[x],y);pu(x);return x;}
    else{ls[y]=mg(x,ls[y]);pu(y);return y;}
}
void ins(int rk,int l,int r){
    int rt=++cnt;
    t[rt]={l,r};ls[rt]=rs[rt]=f[rt]=0;
    sz[rt]=r-l+1;rnd[rt]=rand();
    mp[l]=rt;
    int x,y;
    sl(RT,rk-1,x,y);
    RT=mg(mg(x,rt),y);
}
void del(int l,int r){
    int x,y,z;
    sl(RT,r,x,z);
    sl(x,l-1,x,y);
    RT=mg(x,z);
}
int find(int rt){
    int res=sz[rt]-sz[rs[rt]];
    while(rt!=RT){
        if(rs[f[rt]]==rt)res+=sz[f[rt]]-sz[rs[f[rt]]];
        rt=f[rt];
    }
    return res;
}
int kth(int p,int k){
    if(k&lt;=sz[ls[p]])return kth(ls[p],k);
    k-=sz[ls[p]];
    if(k-t[p].r+t[p].l-1&lt;=0)return t[p].l+k-1;
    return kth(rs[p],k-t[p].r+t[p].l-1);
}
int n,m,u,x;
int main(){
    n=gi();m=gi();
    mp[1]=1;
    ins(1,1,n);
    for(int i=1;i&lt;=m;++i){
        int u=gi(),x=gi()-la,y;
        if(u==1){
            y=gi()-la;
            int l=(--mp.lower_bound(x+1))-&gt;first;
            int p=mp[l],r=t[p].r;
            int rk=la=find(p)-r+x;
            printf(&quot;%d\n&quot;,rk);
            del(rk-x+l,rk+r-x);
            if(x&gt;l)ins(rk-x+l,l,x-1);
            ins(rk,y,y);
            if(r&gt;x)ins(rk+1,x+1,r);
        }
        if(u==2){
            int l=(--mp.lower_bound(x+1))-&gt;first;
            int p=mp[l],r=t[p].r;
            int rk=la=find(p)-r+x;
            printf(&quot;%d\n&quot;,rk);
            del(rk-x+l,rk+r-x);
            if(x&gt;l)ins(rk-x+l,l,x-1);
            if(r&gt;x)ins(rk,x+1,r);
            ins(1,x,x);
        }
        if(u==3){
            int l=(--mp.lower_bound(x+1))-&gt;first;
            int p=mp[l],r=t[p].r;
            int rk=la=find(p)-r+x;
            printf(&quot;%d\n&quot;,rk);
            del(rk-x+l,rk+r-x);
            if(x&gt;l)ins(rk-x+l,l,x-1);
            if(r&gt;x)ins(rk,x+1,r);
            ins(n,x,x);
        }
        if(u==4)printf(&quot;%d\n&quot;,la=kth(RT,x));
    }
}
</code></pre>
</div></div></div><div class="mdui-row-xs-3 article"><div class="mdui-col"><a href="/posts/标记永久化/" class="text" id='pre_button'><i class="mdui-icon material-icons">arrow_back</i>标记永久化</a></div><div class="mdui-col mdui-text-center">fhqtreap</div><div class="mdui-col"><a href="/posts/treap/" class="text mdui-float-right" id='nxt_button'>treap<i class="mdui-icon material-icons">arrow_forward</i></a></div></div><div class="mdui-card" style="margin-top: 50px;"><div class="mdui-card-primary"><div class="mdui-card-primary-title"><i class="mdui-icon material-icons">comment</i>评论</div></div><div class="mdui-card-content" id='comments'><center><div class="mdui-spinner"></div></center></div></div><script>
function SetComment(){
    window.comment=new Valine({
        el: '#comments',
        placeholder: "说几句嘛qwq",
        appId: "NLh0fhLRvD8gOWEC3vtOIRx5-gzGzoHsz",
        appKey: "DSwqdjPFKAnO4CFMQypfkcB9",
        path: window.location.pathname,
    });
}
function GenComment(){
    document.getElementById('comments').innerHTML=`<center><div class="mdui-spinner mdui-spinner-colorful"></div></center>`;
    mdui.mutation(document.getElementById('comments'));

    if(document.getElementById("comment_js"))SetComment();
    else{
        var valinejs=document.createElement('script');
        valinejs.id="comment_js";
        valinejs.src="https://cdn.jsdelivr.net/gh/xCss/Valine/dist/Valine.min.js";
        valinejs.async=true;
        valinejs.onload=SetComment;
    }
    document.getElementsByTagName("head")[0].appendChild(valinejs);
}
</script></div><div class="mdui-drawer mdui-drawer-close" id="drawer"><ul class="mdui-list"><li class='mdui-subheader'>Pages</li><li class="mdui-list-item"><i class="mdui-list-item-icon mdui-icon material-icons"">bookmark_border</i><a href="/tags/" target="_blank" rel="noopener" class="mdui-list-item-content">标签云</a></li><li class="mdui-list-item"><i class="mdui-list-item-icon mdui-icon material-icons"">book</i><a href="/categories/" target="_blank" rel="noopener" class="mdui-list-item-content">分类</a></li><li class="mdui-list-item"><i class="mdui-list-item-icon mdui-icon material-icons"">link</i><a href="/links/" target="_blank" rel="noopener" class="mdui-list-item-content">友链</a></li><li class="mdui-list-item"><i class="mdui-list-item-icon mdui-icon material-icons"">build</i><a href="/tools/" target="_blank" rel="noopener" class="mdui-list-item-content">工具集</a></li><li class="mdui-list-item"><i class="mdui-list-item-icon mdui-icon material-icons"">person</i><a href="/about/" target="_blank" rel="noopener" class="mdui-list-item-content">关于我</a></li><li class="mdui-list-item"><i class="mdui-list-item-icon mdui-icon material-icons"">rss_feed</i><a href="/atom.xml" target="_blank" rel="noopener" class="mdui-list-item-content">订阅</a></li><li class="mdui-list-item"><i class="mdui-list-item-icon mdui-icon material-icons"">list</i><a href="/sitemap.xml" target="_blank" rel="noopener" class="mdui-list-item-content">站点地图</a></li><li class="mdui-list-item"><i class="mdui-list-item-icon mdui-icon material-icons"">comment</i><a href="https://nlh0fhlrsgij.leanapp.cn/" target="_blank" rel="noopener" class="mdui-list-item-content">评论管理</a></li><li class='mdui-subheader'>Catch me</li><li class="mdui-list-item"><i class="mdui-list-item-icon mdui-icon material-icons"style='color:dodgerblue'">email</i><a href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=fwUcIBIWEhY-Dg5RHBAS" target="_blank" rel="noopener" class="mdui-list-item-content">给我写信</a></li><li class="mdui-list-item"><i class="mdui-list-item-icon mdui-icon mqii mqii-telegram"style='color:#66ccff'"></i><a href="https://t.me/zcmimi/" target="_blank" rel="noopener" class="mdui-list-item-content">电报</a></li><li class="mdui-list-item"><i class="mdui-list-item-icon mdui-icon mqii mqii-twitter"style='color:rgba(29,161,242,1.00)'"></i><a href="https://twitter.com/zc_mimi/" target="_blank" rel="noopener" class="mdui-list-item-content">推特</a></li><li class="mdui-list-item"><i class="mdui-list-item-icon mdui-icon mqii mqii-bilibili"style='color:#F06292'"></i><a href="https://space.bilibili.com/110897068/" target="_blank" rel="noopener" class="mdui-list-item-content">哔哩哔哩</a></li><li class="mdui-list-item"><i class="mdui-list-item-icon mdui-icon mqii mqii-netease-cloud-music"style='color:red'"></i><a href="https://music.163.com/user/home/?id=507163653" target="_blank" rel="noopener" class="mdui-list-item-content">网易云音乐</a></li><li class="mdui-list-item"><i class="mdui-list-item-icon mdui-icon mqii mqii-zhihu"style='color:#0084ff'"></i><a href="https://www.zhihu.com/people/zcmimi/" target="_blank" rel="noopener" class="mdui-list-item-content">知乎</a></li><li class="mdui-list-item"><i class="mdui-list-item-icon mdui-icon mqii mqii-github""></i><a href="https://github.com/zcmimi/" target="_blank" rel="noopener" class="mdui-list-item-content">Github</a></li><li class='mdui-subheader'>Links</li><li class="mdui-list-item"><img class="mdui-list-item-icon" src="https://cdn.jsdelivr.net/gh/zcmimi/cdn@master/avatar/avatar64x64.webp" alt><a href="https://zcmimi.top/" target="_blank" rel="noopener" class="mdui-list-item-content">index</a></li><li class="mdui-list-item"><i class="mdui-list-item-icon mdui-icon mqii mqii-telegram"style='color:#bbb'"></i><a href="https://travellings.now.sh/" target="_blank" rel="noopener" class="mdui-list-item-content">Traveling</a></li></ul></div><div class="mdui-drawer mdui-drawer-close mdui-drawer-right" id="toc_drawer" hidden><ul class="mdui-list" id="toc"></ul></div></body><button class="mdui-fab mdui-fab-mini mdui-fab-fixed mdui-fab-hide" id="totop" onclick="totop()" style="z-index: 99999;"><i class="mdui-icon material-icons">keyboard_arrow_up</i></button><footer class="mdui-m-t-5"><div class="mdui-card"><div class="mdui-card-content mdui-p-a-5"><div class="mdui-container"><div class="mdui-row-sm-3"><div class="mdui-col"><div class="mdui-row"><div class="mdui-col-xs-2 mdui-col-sm-1 mdui-col-md-1" style="margin: 10px;"><a href="https://github.com/zcmimi/" target="_blank" rel="noopener"><i class="mdui-icon mqii mqii-github"></i></a></div><div class="mdui-col-xs-2 mdui-col-sm-1 mdui-col-md-1" style="margin: 10px;"><a href="https://space.bilibili.com/110897068/" target="_blank" rel="noopener"><i class="mdui-icon mqii mqii-bilibili"></i></a></div><div class="mdui-col-xs-2 mdui-col-sm-1 mdui-col-md-1" style="margin: 10px;"><a href="https://www.zhihu.com/people/zcmimi/" target="_blank" rel="noopener"><i class="mdui-icon mqii mqii-zhihu"></i></a></div><div class="mdui-col-xs-2 mdui-col-sm-1 mdui-col-md-1" style="margin: 10px;"><a href="https://twitter.com/zc_mimi/" target="_blank" rel="noopener"><i class="mdui-icon mqii mqii-twitter"></i></a></div></div></div><div class="mdui-col mdui-text-center"><span>Copyright ©&nbsp;2019-2020&nbsp;zcmimi's blog</span></div><div class="mdui-col mdui-text-center mdui-typo"><div>Powered by<a href="https://github.com/zcmimi/py-blog" target="_blank" rel="noopener">py-blog</a></div><div>Theme<a href="https://github.com/zcmimi/py-blog-theme-material" target="_blank" rel="noopener">material</a></div></div></div></div></div></div></footer><div class="mdui-dialog" id="search_dialog" style="min-height: 50%;"><div class="mdui-dialog-title">Search</div><div class="mdui-dialog-content"><div class="mdui-textfield"><i class="mdui-icon material-icons">search</i><input id="search_input" class="mdui-textfield-input" placeholder="搜索"></div><div id="search_result" class="mdui-list"></div></div></div><script async src='/assets/serverless_search.js'></script><script>document.getElementById('search_input').onchange=function(){search("https://search.blog.zcmimi.top");}</script><script async defer src="/assets/mdui/js/mdui.min.js"></script><script async defer src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/highlight.min.js"></script><script async defer src="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.js"></script><script defer src='/assets/bundle.min.js'></script><script defer src='/custom.js'></script><script defer>
var pjaxjs=document.createElement("script");
pjaxjs.src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js";pjaxjs.async=true;
pjaxjs.onload=()=>{
    var pjax=new Pjax({elements:"a",selectors:["title","#TOC",".mdui-container",".js-pjax"]});
    document.addEventListener('pjax:send',()=>{document.getElementById('loading-progress').hidden=0;});
    document.addEventListener('pjax:complete',()=>{document.getElementById('loading-progress').hidden=1;pjax_load();});
}
document.getElementsByTagName("head")[0].append(pjaxjs);
</script><script defer>
window.addEventListener('load',()=>{try{GenComment();}catch{}});
document.addEventListener('pjax:complete',()=>{try{GenComment();}catch{}});
</script></html>