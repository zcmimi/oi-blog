<!DOCTYPE html><html lang="zh-CN"><head><title>容斥与二项式反演 - zcmimi's blog</title><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="dns-prefetch" href="https://oi.zcmimi.top/"><link rel="preload" href="/assets/mdui/css/mdui.min.css" as="style"><link rel="stylesheet" href="/assets/mdui/css/mdui.min.css"><link rel="preload" href="/assets/theme/origin.css" as="style"><link rel="stylesheet" href="/assets/theme/origin.css"><link rel="stylesheet" href="/assets/icon/mqii/mqii.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/styles/github.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="/assets/markdown.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="/custom.css"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/zcmimi/cdn@master/avatar/avatar.svg"><meta name="name" itemprop="name" content="zcmimi's blog"><meta name="description" itemprop="description" content="zcmimi的博客"><meta name="keywords" itemprop="keywords" content="oi 博客 信息学"><meta name="image" itemprop="image" content="https://cdn.jsdelivr.net/gh/zcmimi/cdn@master/avatar/avatar.svg"><meta property="og:url" content="https://oi.zcmimi.top/"><meta property="og:type" content="blog"><meta property="og:title" content="zcmimi's blog"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/zcmimi/cdn@master/avatar/avatar.svg"><meta property="og:description" content="zcmimi的博客"><link rel="canonical" href="https://oi.zcmimi.top/"><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "Website",
    "publisher":{
        "@type":"Organization",
        "name":"zcmimi's blog",
        "logo":"https://cdn.jsdelivr.net/gh/zcmimi/cdn@master/avatar/avatar.svg"
    },
    "url":"https://oi.zcmimi.top/",
    "image":{
        "@type":"ImageObject",
        "url":"https://cdn.jsdelivr.net/gh/zcmimi/cdn@master/avatar/avatar.svg"
    },
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://oi.zcmimi.top/"
    },
    "description":""
}</script></head><body class="mdui-appbar-with-toolbar mdui-theme-accent-blue"><div class="mdui-progress" id='loading-progress' style="position: fixed;top:0;z-index: 999999;"><div class="mdui-progress-indeterminate"></div></div><div id="theme_css"></div><div class="mdui-appbar mdui-appbar-fixed mdui-appbar-scroll-hide"><div class="mdui-toolbar"><button class="mdui-btn mdui-btn-icon" mdui-drawer="{target:'#drawer'}" mdui-tooltip="{content: '菜单'}"><i class="mdui-icon material-icons">menu</i></button><a href="/" class="mdui-typo-title">zcmimi's blog</a><div class="mdui-toolbar-spacer"></div><div class="mdui-row mdui-hidden-sm-down"><a href="https://zcmimi.top/" target="_blank" rel="noopener" class="mdui-col text">主页</a><a href="/categories/" target="_blank" rel="noopener" class="mdui-col text">分类</a><a href="/tags/" target="_blank" rel="noopener" class="mdui-col text">标签云</a><a href="/categories/刷题记录/" target="_blank" rel="noopener" class="mdui-col text">刷题记录</a><a href="/links/" target="_blank" rel="noopener" class="mdui-col text">友链</a><a href="/tools/" target="_blank" rel="noopener" class="mdui-col text">工具集</a><a href="/about/" target="_blank" rel="noopener" class="mdui-col text">关于我</a><a href="https://travellings.now.sh/" target="_blank" rel="noopener" class="mdui-col text">Traveling</a></div><button class="mdui-btn mdui-btn-icon" mdui-tooltip="{content: '切换主题'}" mdui-menu="{target: '#theme_menu',align: 'right',covered: false}"><i class="mdui-icon material-icons">view_quilt</i></button><ul class="mdui-menu" id="theme_menu" style="width: fit-content;"><li class="mdui-menu-item" mdui-tooltip="{content: '回归原本'}"><a onclick="theme('day')">日间模式</a></li><li class="mdui-menu-item" mdui-tooltip="{content: '晚上要保护眼睛哦'}"><a onclick="theme('night')">夜间模式</a></li><li class="mdui-menu-item" mdui-tooltip="{content: '满足你的少女心吧'}"><a onclick="theme('pink')">粉红</a></li><li class="mdui-menu-item" mdui-tooltip="{content: '没什么,就是淡蓝色'}"><a onclick="theme('blue')">粉蓝</a></li></ul><button mdui-dialog="{target:'#search_dialog'}" onclick="document.getElementById('search_input').focus();" class="mdui-btn mdui-btn-icon" mdui-tooltip="{content: '搜索'}"><i class="mdui-icon material-icons">search</i></button><button id='toc_button' class="mdui-btn mdui-btn-icon" mdui-drawer="{target:'#toc_drawer'}" mdui-tooltip="{content: '目录'}" hidden><i class="mdui-icon material-icons">format_list_numbered</i></button></div></div><div class="mdui-container"><div id='page_typ' hidden>article</div><div class="mdui-card article"><div class="mdui-card-primary"><a href="/posts/容斥/" class="mdui-card-primary-title">容斥与二项式反演</a><div class="mdui-card-primary-subtitle"><a href="/tags/数论/" class="mdui-chip"><span class="mdui-chip-title">数论</span></a><a href="/tags/容斥/" class="mdui-chip"><span class="mdui-chip-title">容斥</span></a><a href="/tags/反演/" class="mdui-chip"><span class="mdui-chip-title">反演</span></a><a href="/tags/组合数/" class="mdui-chip"><span class="mdui-chip-title">组合数</span></a><a href="/tags/二项式反演/" class="mdui-chip"><span class="mdui-chip-title">二项式反演</span></a></div></div><div class="mdui-card-header"><img data-src="https://cdn.jsdelivr.net/gh/zcmimi/cdn@master/avatar/avatar64x64.png" src='/assets/icon/loading.svg' alt='avatar' class="mdui-card-header-avatar"><div class="mdui-card-header-title">zcmimi</div><div class="mdui-card-header-subtitle">2019-12-01</div><div class="mdui-card-menu"><button class="mdui-btn mdui-btn-icon" mdui-tooltip="{content: '文章分类'}" mdui-menu="{target:'#categories-list',align:'right',covered: false}"><i class="mdui-icon material-icons">bookmark</i></button><ul class="mdui-menu" id="categories-list"><li class="mdui-menu-item"><a href="/categories/算法/数论/">算法/数论</a></li><li class="mdui-menu-item"><a href="/categories/note/">note</a></li></ul><button class="mdui-btn mdui-btn-icon" mdui-tooltip="{content: '分享'}" mdui-menu="{target:'#share_menu',align:'right',covered: false}"><i class="mdui-icon material-icons">share</i></button><ul class="mdui-menu" id="share_menu" style="width: fit-content;"><li class="mdui-menu-item"><a id="share_weibo" href="https://service.weibo.com/share/share.php?appkey=&title=容斥与二项式反演 - zcmimi's blog&url=/posts/容斥/&pic=https://cdn.jsdelivr.net/gh/zcmimi/cdn@master/avatar/avatar.svg&style=simple" target="_blank" rel="noopener"><i class="mdui-menu-item-icon mdui-icon mqii mqii-weibo"></i>分享到微博</a></li><li class="mdui-menu-item"><a id="share_qq" href="https://connect.qq.com/widget/shareqq/index.html?site=zcmimi's blog&title=容斥与二项式反演 - zcmimi's blog&summary=&pics=https://cdn.jsdelivr.net/gh/zcmimi/cdn@master/avatar/avatar.svg&url=/posts/容斥/" target="_blank" rel="noopener"><i class="mdui-menu-item-icon mdui-icon mqii mqii-qq_filled"></i>分享到QQ</a></li><li class="mdui-menu-item"><a id="share_twitter" href="https://twitter.com/intent/tweet?text=容斥与二项式反演 - zcmimi's blog&url=/posts/容斥/" target="_blank" rel="noopener"><i class="mdui-menu-item-icon mdui-icon mqii mqii-twitter"></i>分享到Twitter</a></li><li class="mdui-menu-item"><a id="share_copy" onclick="copylink()"><i class="mdui-menu-item-icon mdui-icon material-icons">link</i>复制链接</a></li></ul></div></div><div class="mdui-card-content"><div id="md-body" class="md-body text"><h1>容斥</h1>
<h2>容斥原理</h2>
<ul>
<li><p>求具有n个属性之一（并集）的元素的个数</p>
</li>
<li><p>求不具有n个属性中任何一个（交集）的元素的个数</p>
</li>
</ul>
<h3>两个集合的并集</h3>
<p><code><latex>|A \bigcup B| = |A|+|B|-|A \bigcap B|</latex></code></p>
<h3>三个集合的并集</h3>
<p><code><latex>
\begin{aligned}
|A \bigcup B \bigcup C|
&=\quad|A|+|B|+|C|\\
&\quad-|A \bigcap B|-|A \bigcap C|-|B \bigcap C|\\
&\quad+|A\bigcap B \bigcap C|
\end{aligned}
</latex></code></p>
<h3>多个集合的并集</h3>
<p>又称多步容斥</p>
<p><code><latex_display>
\begin{aligned}
&\quad|A_1 \bigcup A_2 \bigcup ... \bigcup A_n|\\
&=\sum_{i=1}^n|A_i|\\
&- \sum_{i=1}^{n-1} \sum_{j=i+1}^n|A_i \bigcap A_j|\\
&+ \sum_{i=1}^{n-2} \sum_{j=i+1}^{n-1}\sum_{k=j+1}^{n}|A_i \bigcap A_j \bigcap A_k|\\
&- ...\\
&+(-1)^{n-1}|A_1 \bigcap A_2 \bigcap ... \bigcap A_n|
\end{aligned}
</latex_display></code></p>
<h3>De Morgan定理</h3>
<p>若<code><latex>A,B</latex></code>是<code><latex>U</latex></code>的子集,则</p>
<p>(<code><latex>\overline A</latex></code>表示<code><latex>A</latex></code>的补集)</p>
<p><code><latex>\overline{A\bigcup B} = \overline A\bigcap \overline B</latex></code></p>
<p><code><latex>\overline{A\bigcap B}=\overline A \bigcup \overline B</latex></code></p>
<p>若<code><latex>A_1,A_2,…A_n</latex></code>是<code><latex>U</latex></code>的子集,则</p>
<p><code><latex>\overline{A_1\bigcup A_2 \bigcup ... \bigcup A_n} = \overline{A_1} \bigcap \overline{A_2} \bigcap ... \bigcap \overline A_n</latex></code></p>
<p><code><latex>\overline{A_1\bigcap A_2 \bigcap ... \bigcap A_n} = \overline{A_1} \bigcup \overline{A_2} \bigcup ... \bigcup \overline A_n</latex></code></p>
<h3>Example 1:</h3>
<p>给定集合<code><latex>N</latex></code>和具有性质<code><latex>i</latex></code>的集合<code><latex>A_1,A_2,...,A_n</latex></code></p>
<p>多步容斥变形:</p>
<p><code><latex_display>
\begin{aligned}
&\quad|\overline{A_1}\bigcap \overline{A_2}\bigcap...\bigcap \overline{A_n}|\\
&=N\\
&-\sum|A_i|\\
&+\sum|A_i\bigcap A_j|\\
&-\sum|A_i\bigcap A_j \bigcap A_k|\\
&+...\\
&+(-1)^n |A_1\bigcap A_2 \bigcap ... \bigcap A_n|
\end{aligned}
</latex_display></code></p>
<p>补集的补集就是原集:</p>
<p><code><latex_display>
\begin{aligned}
&\quad|A_1\bigcap A_2\bigcap...\bigcap A_n|\\
&=N\\
&-\sum|\overline{A_i}|\\
&+\sum|\overline{A_i} \bigcap \overline{A_j}|\\
&-\sum|\overline{A_i} \bigcap \overline{A_j} \bigcap \overline{A_k}|\\
&+...\\
&+(-1)^n |\overline{A_1}\bigcap \overline{A_2} \bigcap ... \bigcap \overline{A_n}|
\end{aligned}
</latex_display></code></p>
<h3>Example 2:</h3>
<blockquote><p>求<code><latex>a,b,c,d,e,f</latex></code>六个字母的全排列中不允许出现<code><latex>ace</latex></code>和<code><latex>df</latex></code>图象的排列数</p>
</blockquote>
<p>设<code><latex>N</latex></code>为总排列数,<code><latex>A</latex></code>为<code><latex>ace</latex></code>出现的排列数,<code><latex>B</latex></code>为<code><latex>df</latex></code>出现的排列数</p>
<p><code><latex_display>
\begin{aligned}
ans
&=|\overline A \bigcap \overline B|\\
&=|N|-|A|-|B|+|A\bigcap B|\\
&=6!-4!-5!+3!=582
\end{aligned}
</latex_display></code></p>
<h3>Example 3:</h3>
<blockquote><p><code><latex>4</latex></code>个<code><latex>x,3</latex></code>个<code><latex>y,2</latex></code>个<code><latex>z</latex></code>的全排列中,求不出现<code><latex>xxxx,yyy,zz</latex></code>图象的排列数.</p>
</blockquote>
<p>设<code><latex>N</latex></code>为总排列集合,出现<code><latex>xxxx</latex></code>的排列集合为<code><latex>A</latex></code>,出现<code><latex>yyy</latex></code>为<code><latex>B</latex></code>,出现<code><latex>zz</latex></code>为<code><latex>C</latex></code></p>
<p><code><latex_display>
\begin{aligned}
ans
&=\quad|N|\\
&\quad-(|A|+|B|+|C|)\\
&\quad+(|A\bigcap B|+|A\bigcap C|+|B\bigcap C|)\\
&\quad-|A\bigcap B\bigcap C|\\
&=1260-(60+105+280)+(12+20+30)-6=871
\end{aligned}
</latex_display></code></p>
<h3>错排问题</h3>
<blockquote><p>求整数<code><latex>1,2,…,n</latex></code>的全排列中所有<code><latex>i</latex></code>都不在第<code><latex>i</latex></code>个位置上的排列的个数,<code><latex>i=1,2,…,n</latex></code></p>
</blockquote>
<p>设<code><latex>A_i</latex></code>为<code><latex>i</latex></code>在位置<code><latex>i</latex></code>上的所有排列</p>
<p><code><latex_display>
\begin{aligned}
ans
&=|\overline A_1\bigcap \overline A_2 \bigcap ...\bigcap \overline A_n|\\
&=\quad|N|\\
&\quad-(|A_1|+|A_2|+...+|A_n|)\\
&\quad+(|A_1\bigcap A_2|+...+|A_{n-1}\bigcap A_n|)\\
&\quad-\ ...\\
&\quad+ (-1)^n |A_1\bigcap A_2\bigcap ... \bigcap A_n|\\
&=n!- {n\choose 1}\cdot (n-1)! + {n\choose 2}\cdot (n-2)! - ...\ + (-1)^n {n\choose n}\\
&=n!(1-\frac{1}{1!}+\frac{1}{2!}-\frac{1}{3!}+...+(-1)^n\frac{1}{n!}) = D_n\\
\end{aligned}
</latex_display></code></p>
<p><code><latex_display>D_n=n!\sum_{i=0}^n \frac{(-1)^i}{i!}</latex_display></code></p>
<p>递推法:</p>
<p>设<code><latex>f_x</latex></code>表示错了<code><latex>x</latex></code>个</p>
<ol>
<li><p>把第<code><latex>n</latex></code>个数放在<code><latex>[1,n-1]</latex></code>中的某个位置,有<code><latex>n-1</latex></code>种可能</p>
</li>
<li><p>放第<code><latex>k(k\not=n)</latex></code>个元素</p>
<ul>
<li><p>放在位置<code><latex>n</latex></code>,剩余的<code><latex>n-2</latex></code>个元素有<code><latex>f_{n-2}</latex></code>种方法</p>
</li>
<li><p>不放位置<code><latex>n</latex></code>,那么相当于剩下<code><latex>n-1</latex></code>个元素有<code><latex>f_{n-1}</latex></code>种方法</p>
</li>
</ul>
</li>
</ol>
<p>初始:<code><latex>f_1=0,f_2=1</latex></code></p>
<p><code><latex>f_n=(n-1)(f_{n-1}+f_{n-2})</latex></code></p>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1465">HDU 1465 不容易系列之一</a></p>
<h2>第二类斯特林数</h2>
<blockquote><p>将<code><latex>n</latex></code>个不同的球放进<code><latex>m</latex></code>个相同的盒子,保证盒子非空,求方案数.</p>
</blockquote>
<h3>容斥法:</h3>
<p><code><latex_display>S(n,m)=\frac 1{m!}\sum_{i=0}^m {m\choose i}(m-i)^n(-1)^i</latex_display></code></p>
<blockquote><p>枚举空盒个数,剩下随便放,到这里开始也有了二项式反演的形式</p>
<p>由于盒子相同,所以除以<code><latex>m!</latex></code></p>
</blockquote>
<h3>递推法</h3>
<p><code><latex_display>S(n,m)=S(n-1,m-1)+mS(n-1,m)</latex_display></code></p>
<blockquote><p>相当于考虑现在要放的求是否单独在一个盒子里:</p>
<ol>
<li><p>不占一盒:</p>
<p>其余<code><latex>n-1</latex></code>个球放到<code><latex>m-1</latex></code>个盒子里</p>
</li>
<li><p>放到某个有球的盒子里:</p>
<p>有<code><latex>m</latex></code>个盒子可放(<code><latex>m</latex></code>种可能),其余<code><latex>n-1</latex></code>个球放到<code><latex>m</latex></code>个盒子里</p>
</li>
</ol>
</blockquote>
<h2>广义容斥原理</h2>
<ul>
<li>求恰好具有m个属性的元素的个数</li>
</ul>
<h3><code><latex>\alpha(m)</latex></code></h3>
<p>给定集合<code><latex>N</latex></code>和性质<code><latex>A_1,A_2,...,A_n</latex></code>,令<code><latex>\alpha(0)=|N|</latex></code></p>
<p><code><latex>\displaystyle
\alpha(1) = \sum|A_i|\\
\alpha(2) = \sum|A_i\bigcap A_j|\\
\alpha(3) = \sum|A_i\bigcap A_j\bigcap A_k|\\
...\\
\alpha(n) = |A_1\bigcap A_2\bigcap ...\bigcap A_n|\\
</latex></code></p>
<p>则<code><latex>\alpha(m)</latex></code>计数了具有<code><latex>m+k</latex></code>个性质的元素<code><latex>{m+k}\choose m</latex></code>次</p>
<h3><code><latex>\beta(m)</latex></code></h3>
<p>给定集合<code><latex>N</latex></code>和性质<code><latex>A_1,A_2,...,A_n</latex></code>,令<code><latex>\beta(m)</latex></code>表示<code><latex>N</latex></code>中恰好有<code><latex>m</latex></code>个性质的元素个数,则</p>
<p><code><latex>\Beta(m)=\alpha(m)-{m+1 \choose m}a(m+1)+{m+2\choose m}\alpha(m+2)-...+(-1)^{n-m}{n\choose m}\alpha(n)</latex></code></p>
<p>证明:请看下面的二项式反演</p>
<p>推论:<code><latex>\beta(0)=\alpha(0)-\alpha(1)+\alpha(2)-...+(-1)^n\alpha(n)</latex></code></p>
<p>我们可以发现这个和接下来的二项式反演非常像,如果无法理解可以强行记一下,因为这个非常对称,很好记</p>
<h2>二项式反演</h2>
<ol>
<li><p>回顾Example 1</p>
<p>考虑一种特殊情况：多个集合的交集大小只和集合的数目有关</p>
<p>设<code><latex>f_n</latex></code>表示<code><latex>n</latex></code>个补集的交集大小,<code><latex>g_n</latex></code>表示<code><latex>n</latex></code>个原集的大小</p>
<p><code><latex_display>
f_n = \sum_{i=0}^n (-1)^i {n\choose i} g_i 
\\\Updownarrow\\ 
g_n = \sum_{i=0}^n (-1)^i {n\choose i}f_i
</latex_display></code></p>
</li>
<li><p>设<code><latex>f_i</latex></code>为至多具有<code><latex>i</latex></code>个属性的方案数,<code><latex>g_i</latex></code>表示恰好具有<code><latex>i</latex></code>个属性的方案数:</p>
<p><code><latex_display>
f_n=\sum_{i=0}^n{n\choose i} g_i
\\ \Updownarrow \\
g_n=\sum_{i=0}^n (-1)^{n-i} {n\choose i}f_i
</latex_display></code></p>
<p><code><latex>f_n</latex></code>表示先钦定<code><latex>n</latex></code>个属性,再统计至多具有这<code><latex>n</latex></code>个属性的方案数(也就是不能有这<code><latex>n</latex></code>个之外的,这<code><latex>n</latex></code>个任意),</p>
<p>其中会包含重复的方案,因为一个方案可以有多种钦定情况.具体地,对于恰好选择<code><latex>i</latex></code>个,钦定情况数位<code><latex>{n\choose i}</latex></code> ,故<code><latex>g_i</latex></code>在<code><latex>f_n</latex></code>中被计算了<code><latex>{n\choose i}</latex></code>次</p>
</li>
<li><p>设<code><latex>f_i</latex></code>为至少具有<code><latex>i</latex></code>个属性,<code><latex>g_i</latex></code>表示恰好具有<code><latex>i</latex></code>个属性的方案数的方案数:</p>
<p><code><latex_display>
f_n = \sum_{i=n}^m g_i {i\choose n}
\\ \Updownarrow \\
g_n=\sum_{i=n}^m(-1)^{i-n}{i\choose n}f_i
</latex_display></code></p>
<p>注意:</p>
<p><code><latex>f_n</latex></code>表示先钦定<code><latex>n</latex></code>个属性,再统计至少具有这<code><latex>n</latex></code>个属性的方案数(也就是包含这<code><latex>n</latex></code>个属性,其余属性任意),</p>
<p>其中会包含重复的方案,因为一个方案可以有多种钦定情况.具体地,对于恰好选择<code><latex>i</latex></code>个,钦定情况数位<code><latex>{i\choose n}</latex></code> ,故<code><latex>g_i</latex></code>在<code><latex>f_i</latex></code>中被计算了<code><latex>{i\choose n}</latex></code>次</p>
</li>
<li><p><strong>tips:</strong></p>
<p><strong>二项式反演</strong>(或<strong>广义容斥原理</strong>)可以用来解决一些<strong>恰好</strong>,<strong>至多</strong>,<strong>至少</strong>的计数问题</p>
<p>可以通过容斥来完成<strong>恰好</strong>,<strong>至多</strong>,<strong>至少</strong>之间的互相转换</p>
<p>是一个很好用的工具</p>
</li>
<li><p>证明</p>
<p>至多:</p>
<p><code><latex_display>
\begin{aligned}
g_n
&=\sum_{i=0}^n (-1)^{n-i}{n\choose i}f_i\\
&=\sum_{i=0}^n (-1)^{n-i} {n\choose i}\sum_{j=0}^i{i\choose j}g_j\\
&=\sum_{j=0}^n g_j\sum_{i=j}^n {n\choose i}{i \choose j}(-1)^{n-i}\\
&=\sum_{j=0}^n g_j\sum_{i=j}^n {n\choose j}{n-j \choose i-j}(-1)^{n-i}\\
&=\sum_{j=0}^n g_j\left[{n\choose j}\sum_{i=j}^n{n-j \choose i-j}(-1)^{n-i}\right]\\
&=\sum_{j=0}^n g_j\left[{n\choose j}\sum_{i=0}^{n-j}{n-j \choose i}(-1)^{n-j-i}\right]\\
&=\sum_{j=0}^n g_j\left[{n \choose j}(1-1)^{n-j}\right]\\
&=g_n
\end{aligned}
</latex_display></code></p>
</li>
</ol>
<h1>例题</h1>
<h2>BZOJ 2839 集合计数</h2>
<p><a href="https://ruanx.pw/bzojch/p/2839.html">地址</a></p>
<h3>题意:</h3>
<p>一个有<code><latex>N</latex></code>个元素的集合有<code><latex>2^N</latex></code>个不同子集（包含空集）,现在要在这<code><latex>2^N</latex></code>个集合中取出若干集合（至少一个）,使得
它们的交集的元素个数为<code><latex>K</latex></code>,求取法的方案数,答案模<code><latex>1000000007</latex></code></p>
<h3>解法:</h3>
<p>设<code><latex>g_i</latex></code>表示交集个数至少为<code><latex>i</latex></code>的方案数</p>
<p>那么<code><latex>\displaystyle g_i = {n\choose i}(2^{2^{n-i}}-1)</latex></code></p>
<blockquote><p>先从<code><latex>n</latex></code>中选<code><latex>i</latex></code>个,然后其他可以随便取</p>
<p>那就是有<code><latex>2^{n-i}</latex></code>个集合可以取</p>
<p>然后又可以取至少1个集合</p>
<p>那么答案就是<code><latex>{n\choose i}(2^{2^{n-i}}-1)</latex></code></p>
</blockquote>
<p>设<code><latex>f_i</latex></code>表示恰好为<code><latex>i</latex></code>的</p>
<p>那么<code><latex>\displaystyle g_k=\sum_{i=k}^n f_i\cdot {i\choose k}</latex></code></p>
<p>反演<code><latex>\displaystyle f_k=\sum_{i=k}^n g_i\cdot{i\choose k} (-1)^{i-k}</latex></code></p>
<p>不能直接快速幂,因为指数不能<code><latex>\mod p</latex></code>,要用<code><latex>2^{2^i}=(2^{2^{i-1}})^2</latex></code>倒着枚举算</p>
<pre><code class="lang-cpp">#define N 1000011
const int mod=1000000007;
int n,k,g[N],fac[N],inv[N];
int C(int a,int b){
    return 1ll*fac[a]*inv[b]%mod*inv[a-b]%mod;
}
int pw(int x,int p){
    int ans=1;
    while(p){
        if(p&amp;1)ans=1ll*ans*x%mod;
        p&gt;&gt;=1;x=1ll*x*x%mod;
    }
    return ans;
}
int main(){
    in(n,k);
    fac[0]=inv[0]=1;
    for(int i=1;i&lt;=n;++i)
        fac[i]=1ll*fac[i-1]*i%mod;
    inv[n]=pw(fac[n],mod-2);
    for(int i=n-1;i&gt;=1;--i)
        inv[i]=1ll*inv[i+1]*(i+1)%mod;

    for(int i=0;i&lt;=n;++i)
        g[i]=1ll*C(n,i)*(pw(2,(pw(2,n-i))-1+mod)%mod)%mod;

    int ans=0,b=2;
    for(int i=n;i&gt;=k;--i){
        int t=1ll*C(n,i)%mod*C(i,k)%mod*(b-1)%mod;
        if((i-k)&amp;1)ans=(ans-t+mod)%mod;
        else ans=(ans+t)%mod;
        b=1ll*b*b%mod;
    }
    printf(&quot;%d\n&quot;,ans);
}
</code></pre>
<h2>[JSOI2011]分特产</h2>
<p><a href="https://www.luogu.com.cn/problem/P5505">地址</a></p>
<h3>题意</h3>
<p>有<code><latex>n</latex></code>个人和<code><latex>m</latex></code>种物品,第<code><latex>i</latex></code>种物品有<code><latex>a_i</latex></code>个,同种物品之间没有区别。现在要将这些物品分给这些人,使得每个人至少分到一个物品</p>
<h3>题解</h3>
<p>每个同学都必须<strong>至少</strong>分得一个</p>
<p>可以通过 <strong>恰好</strong>没有同学没有分得 来反演</p>
<p>设<code><latex>f_i</latex></code>为钦定<code><latex>i</latex></code>个人没有分到,</p>
<p>钦定的方案数为<code><latex>{n\choose i}</latex></code>,这时第<code><latex>j</latex></code>种物品分给<code><latex>n-i</latex></code>个人,使用隔板法,方案数为<code><latex>{n-i+a_j-1\choose n-i-1}</latex></code></p>
<p><code><latex_display>
f_i={n\choose i}\prod_{j=1}^m{n-i+a_j-1\choose n-i-1}
</latex_display></code></p>
<p>设<code><latex>g_i</latex></code>为恰好<code><latex>i</latex></code>个人没有分到,反演:</p>
<p><code><latex_display>
g_k=\sum_{i=k}^n(-1)^{i-k}{i \choose k}f_i
</latex_display></code></p>
<p>那么:</p>
<p><code><latex_display>
\begin{aligned}
ans
&=g_0\\
&=\sum_{i=0}^n(-1)^if_i\\
&=\sum_{i=0}^n(-1)^i{n\choose i}\prod_{j=1}^m{n-i+a_j-1\choose n-i-1}
\end{aligned}
</latex_display></code></p>
<pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;
const int N=1001,P=1000000007;
int n,m,a[N],ans,c[N*2][N*2];
void mod(int&amp;x){if(x&gt;=P)x-=P;}
int main(){
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    for(int i=0;i&lt;=2000;++i){
        c[i][0]=c[i][i]=1;
        for(int j=1;j&lt;i;++j)
            mod(c[i][j]=c[i-1][j-1]+c[i-1][j]);
    }
    for(int i=1;i&lt;=m;++i)scanf(&quot;%d&quot;,a+i);
    for(int i=0;i&lt;=n;++i){
        long long res=c[n][i];
        for(int j=1;j&lt;=m;++j)
            (res*=c[n-i+a[j]-1][n-i-1])%=P;
        if(i&amp;1)mod(ans+=P-res);
        else mod(ans+=res);
    }
    printf(&quot;%d\n&quot;,ans);
}
</code></pre>
<h2>已经没有什么好害怕的了</h2>
<p><a href="https://www.luogu.com.cn/problem/P4859">地址</a></p>
<h3>题意:</h3>
<p>给出<code><latex>n</latex></code>个数<code><latex>a_i</latex></code>及<code><latex>n</latex></code>个数<code><latex>b_i</latex></code> ,要求两两配对使得 <code><latex>a>b</latex></code>的对数减去<code><latex>a&lt;b</latex></code>的对数等于<code><latex>k</latex></code>.</p>
<p><code><latex>0\leq k\leq n\leq 2000</latex></code>,保证<code><latex>a,b</latex></code> 无相同元素.</p>
<h3>题解:</h3>
<p>先将<code><latex>b</latex></code>数组从小到大排序</p>
<p>设选中了<code><latex>x</latex></code>对<code><latex>a > b</latex></code>,由总对数为<code><latex>n</latex></code>,由<code><latex>x-(n-x)=k</latex></code>,可以知道<code><latex>x=\frac{n+k}2</latex></code></p>
<p>我们设<code><latex>f(i,j)</latex></code>为前<code><latex>i</latex></code>个<code><latex>a</latex></code>中选中了<code><latex>j</latex></code>组<code><latex>a > b</latex></code>的方案数</p>
<p>那么<code><latex>f(i,j)=f(i-1,j)+f(i-1,j-1)\times(l_i-j+1)</latex></code></p>
<p>(<code><latex>l_i</latex></code>表示<code><latex>b</latex></code>中小于<code><latex>a_i</latex></code>的最后一个位置)</p>
<p>但是还有剩下的<code><latex>n-x</latex></code>对</p>
<p>我们可以设<code><latex>g_i</latex></code>表示<code><latex>a>b</latex></code>对数<code><latex>\ge i</latex></code>的方案数</p>
<p>那么<code><latex>g_i = f(n,i) \times (n-i)!</latex></code>(相当于剩下的随便排列组合)</p>
<p>我们设<code><latex>f_i</latex></code>表示<code><latex>a>b</latex></code>对数恰好为<code><latex>i</latex></code>对的方案数</p>
<p>那么<code><latex>\displaystyle g_k = \sum_{i=k}^n f_i \times {i\choose k}</latex></code>
 (相当于从恰好<code><latex>i</latex></code>个方案中选<code><latex>k</latex></code>对出来)</p>
<p>经过二项式反演可以知道:</p>
<p><code><latex>\displaystyle f(k)=\sum_{i=k}^n(-1)^{i-k}{i\choose k}g(i)</latex></code></p>
<p>代码:</p>
<pre><code class="lang-cpp">const int N=4011,mod=1000000009;
int n,k,f[N][N],a[N],b[N],l[N],fac[N],inv[N],g[N];
il int pw(int x,int p){
    int ans=1;
    while(p){
        if(p&amp;1)ans=1ll*ans*x%mod;
        p&gt;&gt;=1;x=1ll*x*x%mod;
    }
    return ans;
}
int C(int a,int b){
    return 1ll*fac[a]*inv[b]%mod*inv[a-b]%mod;
}
signed main(){
    in(n,k);
    if((n+k)&amp;1){puts(&quot;0&quot;);return 0;};
    k=(n+k)&gt;&gt;1;
    for(int i=1;i&lt;=n;++i)in(a[i]);
    for(int i=1;i&lt;=n;++i)in(b[i]);
    fac[0]=inv[0]=1;
    for(int i=1;i&lt;=n;++i)
        fac[i]=1ll*fac[i-1]*i%mod;
    inv[n]=pw(fac[n],mod-2);
    for(int i=n-1;i&gt;=0;--i)
        inv[i]=1ll*inv[i+1]*(i+1)%mod;
    sort(a+1,a+n+1);
    sort(b+1,b+n+1);
    int p=0;
    for(int i=1;i&lt;=n;++i){
        while(p&lt;n&amp;&amp;b[p+1]&lt;a[i])++p;
        l[i]=p;
    }
    f[0][0]=1;
    for(int i=1;i&lt;=n;++i){
        f[i][0]=1;
        for(int j=1;j&lt;=i;++j)
            f[i][j]=(f[i-1][j]+1ll*f[i-1][j-1]*MAX(0,l[i]-j+1)%mod)%mod;
    }
    for(int i=0;i&lt;=n;++i)
        g[i]=1ll*f[n][i]*fac[n-i]%mod;
    int ans=0;
    for(int i=k;i&lt;=n;++i)
        if((i-k)&amp;1)ans=(ans-1ll*C(i,k)*g[i]%mod+mod)%mod;
        else ans=(ans+1ll*C(i,k)*g[i]%mod)%mod;

    printf(&quot;%d\n&quot;,ans);
}
</code></pre>
<h2>[HAOI2008]硬币购物</h2>
<p><a href="https://www.luogu.com.cn/problem/P1450">地址</a></p>
<h3>题意:</h3>
<p>硬币购物一共有4种硬币.面值分别为<code><latex>c1,c2,c3,c4</latex></code>.</p>
<p>某人去商店买东西,去了<code><latex>tot</latex></code>次.</p>
<p>每次带<code><latex>d_i</latex></code>枚<code><latex>c_i</latex></code>硬币,买<code><latex>s_i</latex></code>的价值的东西.</p>
<p>请问每次有多少种付款方法.</p>
<h3>题解:</h3>
<p>先考虑每种硬币可以用无数次</p>
<p>设<code><latex>f_i</latex></code>表示金额为<code><latex>i</latex></code>有多少种方案</p>
<p>那么<code><latex>\displaystyle f_i = \sum_{j=1}^4 f_{i-c[j](i \ge c_j)}</latex></code></p>
<p>我们再来考虑硬币使用次数有限制怎么办</p>
<blockquote><p>不合法的情况有:</p>
<p>1超额</p>
<p>1,2超额</p>
<p>1,3超额</p>
<p>1,4超额</p>
<p>1,2,3超额</p>
<p>1,2,4超额</p>
<p>1,3,4超额</p>
<p>1,2,3,4超额</p>
<p>...</p>
<p>要注意的是在多种硬币限制的情况下可能会减去多次,或加上多次</p>
<p>比如1超额,2超额,（1,2同时超额被减去两次,这是就要加回来</p>
<p>而<code><latex>(1,2,3)</latex></code> 、<code><latex>(1,2,4)</latex></code>又是多算的...</p>
</blockquote>
<p>是不是更直观的了解了容斥？</p>
<p>为了方便,我们可以枚举二进制下状态来更加优美实现.</p>
<p>(当有奇数种不合法的时候减去,偶数种不合法时加上)</p>
<p>代码:</p>
<pre><code class="lang-cpp">#define N 100011
int n,c[5],d[5],s;
ll f[N];
int main(){
    for(int i=1;i&lt;=4;++i)in(c[i]);
    f[0]=1;
    for(int i=1;i&lt;=4;++i)
        for(int j=c[i];j&lt;=100000;++j)
            f[j]+=f[j-c[i]];

    in(n);
    while(n--){
        for(int i=1;i&lt;=4;++i)in(d[i]);
        in(s);
        ll ans=f[s];
        for(int i=1;i&lt;=15;++i){
            int t=s,sta=i,k=1;
            for(int j=1;j&lt;=4;++j)
            if(sta&amp;(1&lt;&lt;(j-1))){
                k=-k;
                t-=(d[j]+1)*c[j];
            }
            if(t&gt;=0)ans+=1ll*f[t]*k;
        }
        out(ans,ln);
    }
}
</code></pre>
<h2>[SDOI2009]Bill的挑战</h2>
<p><a href="https://www.luogu.com.cn/problem/P2167">地址</a></p>
<h3>题意:</h3>
<p>给<code><latex>n</latex></code>个长度相同的字符串(由小写字母和<code>?</code>组成):<code><latex>S_1,S_2,...,S_n</latex></code>,</p>
<p>求这<code><latex>n</latex></code>个串中的刚好<code><latex>k</latex></code>个串匹配的字符串<code><latex>T</latex></code>的个数<code><latex>\pmod{1000003}</latex></code></p>
<p>若<code><latex>S_x</latex></code>与<code><latex>T</latex></code>匹配,满足:</p>
<ol>
<li><code><latex>|S_x|=|T|</latex></code></li>
<li><code><latex>\forall S_x[i]=?||S_x[i]=T[i]</latex></code></li>
</ol>
<h3>状压解法:</h3>
<p>设<code><latex>f[i][j]</latex></code>表示到了第<code><latex>i</latex></code>位,匹配的状态为<code><latex>j</latex></code></p>
<p>代码:</p>
<pre><code class="lang-cpp">#define N 111
#define mod 1000003
#define M(x) ((x&gt;=mod)?(x)%=mod:x)
int mt[N][30];
ll f[N][1&lt;&lt;15];
char ch[N][N];
il void work(){
    clr(mt,0);
    clr(f,0);
    int n,k,len;
    in(n,k);
    for(int i=1;i&lt;=n;++i)in(ch[i]);
    len=strlen(ch[1]);
    for(int i=0;i&lt;=len-1;++i)
        for(char t=&#39;a&#39;;t&lt;=&#39;z&#39;;++t)
            for(int j=1;j&lt;=n;++j)
            if(ch[j][i]==&#39;?&#39;||ch[j][i]==t)
                mt[i][t-&#39;a&#39;]|=(1&lt;&lt;(j-1));//更新比较当前位的影响
    f[0][(1&lt;&lt;n)-1]=1;
    for(int i=0;i&lt;=len-1;++i)
        for(int j=0;j&lt;(1&lt;&lt;n);++j)
        if(f[i][j])
            for(int t=0;t&lt;=26;++t)
                M(f[i+1][j&amp;mt[i][t]]+=f[i][j]);
    ll ans=0;
    for(int i=0;i&lt;(1&lt;&lt;n);++i){
        int t=i,tt=0;
        while(t)tt+=(t&amp;1),t&gt;&gt;=1;
        if(tt==k)M(ans+=f[len][i]);
    }
    out(ans,ln);
}
int main(){
    int T;in(T);
    while(T--)work();
    flush();
}
</code></pre>
<h3>容斥解法:</h3>
<p>看到恰好<code><latex>k</latex></code>个,我们就可以想到容斥套路</p>
<p>找出至少匹配<code><latex>k</latex></code>个的方案数<code><latex>g(k)</latex></code>,设<code><latex>f(k)</latex></code>为恰好<code><latex>k</latex></code>个的方案数</p>
<p>然后还是按套路就可以了</p>
<p><code><latex_display>
g(n) = \sum_{i=k}^n {n\choose i}f(i)
\\
\Updownarrow
\\
f(n) = \sum_{i=k}^n {n\choose i}g(i) (-1)^{i-k}
</latex_display></code></p>
<p>问题转换为如何求至少匹配<code><latex>k</latex></code>个的方案数</p>
<p>我们可以使用dfs来统计,这样比起状压思维难度可能降低了许多,只需要枚举排列组合(当然枚举二进制状态也可以)</p>
<p>状压需要处理全部状态</p>
<p>dfs只需要统计<code><latex>k</latex></code>～<code><latex>n</latex></code>的部分</p>
<p>最后统计的时间可忽略不计</p>
<p>状压:<code><latex>492ms</latex></code></p>
<p>容斥: <code><latex>100ms</latex></code></p>
<p>容斥代码:</p>
<pre><code class="lang-cpp">#define N 111
#define mod 1000003
char ch[N][N];
int len,n,k,cnt,c[N][N],up,tot=0,las,a[N];
void dfs(int x,int now){
    if(x==n+1){
        if(now!=up)return;
        ll lp=1;
        for(int j=1;j&lt;=len;++j){
            las=-1;
            for(int i=1;i&lt;=up;++i)
            if(ch[a[i]][j]!=&#39;?&#39;){
                if(las==-1)
                    las=ch[a[i]][j]-&#39;a&#39;;
                else if(las!=ch[a[i]][j]-&#39;a&#39;)return;
            }
            if(las==-1)lp=(lp*26)%mod;
        }
        (tot+=lp)%=mod;
        return;
    }
    if(now&lt;up){
        a[++cnt]=x;
        dfs(x+1,now+1);
        a[cnt--]=0;
    }
    if(n-x&gt;=up-now)dfs(x+1,now);
}
ll g[N];
il void work(){
    clr(g,0);
    in(n,k);
    for(int i=1;i&lt;=n;++i)in(ch[i]+1);
    len=strlen(ch[1]+1);
    for(int i=k;i&lt;=n;++i)
        up=i;
        tot=0;
        dfs(1,0);
        g[i]=tot;
    }

    // 容斥部分:
    ll ans=0;
    for(int i=k;i&lt;=n;++i)
        if((i-k)&amp;1)ans=(ans-1ll*c[i][k]*g[i]%mod+mod)%mod;
        else ans=(ans+1ll*c[i][k]*g[i]%mod)%mod;
    out(ans,ln);
}
int main(){
    for(int i=0;i&lt;=20;++i){
        c[i][0]=1;
        for(int j=1;j&lt;=i;++j)
            c[i][j]=c[i-1][j]+c[i-1][j-1];
    }
    int T;in(T);
    while(T--)work();
    flush();
}
</code></pre>
<p>其他有关容斥题目:</p>
<h2>Emiya 家今天的饭</h2>
<p><a href="https://www.luogu.com.cn/problem/P5664">地址</a></p>
<h3>题意:</h3>
<p>给出一个矩阵,要求每行只能选一个节点,每列选的节点不能超过所有选的节点的一半,不能不选,
给出每个节点的选择方案数,求总方案数</p>
<h3>解法:</h3>
<p>考虑到限制是每列选择的不能超过一半,我们可以想到不合法的最多只有一列</p>
<p>我们可以用总方案数减去不符合的</p>
<p><code><latex>\displaystyle s_i=\sum_{j=1}^m a_{ij}</latex></code></p>
<p>总方案数:<code><latex>\displaystyle \prod_{i=1}^n (s_i+1) - 1</latex></code></p>
<p><code><latex>\because k=\frac {tot}2</latex></code></p>
<p>所以我们有一个很妙的方法:</p>
<p>设选中目标行之外的权值+1,不选+0,选中目标行权值位+2</p>
<p>最后只要权值<code><latex>> n</latex></code>,那么目标行一定被选了超过<code><latex>\frac n2</latex></code>次</p>
<p>设<code><latex>f(i,k)</latex></code>表示总共选了<code><latex>i</latex></code>次(也就是选到第<code><latex>i</latex></code>行)权值为<code><latex>k</latex></code>的方案数</p>
<p><code><latex>f(i,k) += f(i-1,k)\cdot(s_i-a_{ij})</latex></code>(当前行不选目标列</p>
<p><code><latex>f(i,k+1) += f(i-1,k)</latex></code>(当前行完全不选</p>
<p><code><latex>f(i,k+2) += f(i-1,k)\times a_{ij}</latex></code>(当前行选中目标列</p>
<p><code><latex>\displaystyle ans = \prod_{i=1}^n (s_i+1) - 1 - \sum_{i=n+1}^{2n} f(n,i)</latex></code></p>
<pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
#define N 111
typedef long long ll;
const int mod=998244353;
int a[N][2011],n,m;
ll f[N][2011],s[N];
int main(){
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    for(int i=1;i&lt;=n;++i)
        for(int j=1;j&lt;=m;++j)
            scanf(&quot;%d&quot;,&amp;a[i][j]),
            s[i]=(s[i]+a[i][j])%mod;

    ll ans=1;
    for(int i=1;i&lt;=n;++i)
        ans=(ans*(s[i]+1))%mod;

    --ans;
    for(int j=1;j&lt;=m;++j){
        memset(f,0,sizeof f);
        f[0][0]=1;
        for(int i=1;i&lt;=n;++i)
            for(int k=0;k&lt;=n*2;++k){
                f[i][k]=(f[i][k]+f[i-1][k]*(s[i]-a[i][j]))%mod;
                f[i][k+1]=(f[i][k+1]+f[i-1][k])%mod;
                f[i][k+2]=(f[i][k+2]+f[i-1][k]*a[i][j])%mod;
            }
        for(int i=n+1;i&lt;=n*2;++i)
            ans=(ans-f[n][i])%mod;
    }
    printf(&quot;%lld\n&quot;,(ans+mod)%mod);
}
</code></pre>
<h2>LG 2567 [SCOI2010]幸运数字</h2>
<p><a href="https://www.luogu.com.cn/problem/P2567">地址</a></p>
<h3>题意:</h3>
<p>定义幸运号码为:由<code><latex>6</latex></code>或<code><latex>8</latex></code>组成的数字</p>
<p>定义近似幸运号码为:幸运号码的倍数</p>
<p>求<code><latex>[l,r]</latex></code>之间幸运数字的个数(<code><latex>1\le l,r \le 10^9</latex></code>).</p>
<h3>题解:</h3>
<p>先预处理出所有幸运数字</p>
<p>当前要求的是<code><latex>[l,r]</latex></code>中的幸运数字</p>
<p>我们可以使用容斥,用<code><latex>[1,r]-[1,l-1]</latex></code></p>
<p>假设当前幸运数字为<code><latex>x</latex></code>,<code><latex>[l,r]</latex></code>中是<code><latex>x</latex></code>的倍数的有<code><latex>\left \lfloor \frac rx \right \rfloor - \left \lfloor \frac lx \right \rfloor +1</latex></code></p>
<p><code><latex>[1,r],[1,l-1]</latex></code>中的幸运数字的倍数可能有交集</p>
<p>继续容斥:</p>
<p>选<code><latex>1</latex></code>个<code><latex>-</latex></code>选<code><latex>2</latex></code>个的<code><latex>lcm+</latex></code>选<code><latex>3</latex></code>个的<code><latex>lcm-...</latex></code></p>
<p>剪枝:</p>
<ol>
<li><p>可以发现,一个数是另一个合法倍数的倍数,那么这个数字相当于没用(因为被前面的统计过了),可以删掉</p>
</li>
<li><p>如果将幸运数字从大到小排序,搜索时可以更快突破边界</p>
</li>
<li><p>现在因为所有数都不满足是另外一个数的倍数,所以合并任意两个数的时候,<code><latex>lcm</latex></code>的最小情况就是乘上一个<code><latex>3</latex></code>,</p>
<p>所以对于所有<code><latex>>r/3</latex></code>的合法数字,显然不能够和任何一个数合并了,所以这一部分可以拿出来直接提前算好</p>
</li>
</ol>
<p>剩下的直接暴搜</p>
<pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
#define N 100011
int tot=0,t=0;
ll ans=0,l,r,a[N];
bool v[N];
inline void init(){
    int h=0;
    while(h&lt;=tot){
        ll x=a[h++]*10;
        if(x+6&lt;=r)a[++tot]=x+6;
        if(x+8&lt;=r)a[++tot]=x+8;
    }
}
const int mod=1000000007;
inline bool chk(ll a,ll b){
    int A=a/mod,B=b/mod;
    if(A*B)return 1;
    return a*b&gt;r;
}
void calc(int x,ll s,int k){
    if(x&gt;tot){
        if(s!=1){
            if(k&amp;1)ans+=r/s-l/s;
            else ans-=r/s-l/s;
        }
        return;
    }
    calc(x+1,s,k);
    ll d=a[x]/__gcd(s,a[x]);
    if(!chk(s,d))calc(x+1,s*d,k+1);
}
inline void work(){
    sort(a+1,a+tot+1);
    for(int i=1;i&lt;=tot;++i)
        for(int j=1;j&lt;i;++j)
        if(a[i]%a[j]==0){
            v[i]=1;
            break;
        }

    for(int i=1;i&lt;=tot;++i)
    if(!v[i]){
        if(a[i]&lt;=r/3)a[++t]=a[i];
        else ans+=r/a[i]-l/a[i];
    }
    tot=t;
    reverse(a+1,a+tot+1);
    calc(1,1,0);
    printf(&quot;%lld\n&quot;,ans);
}
int main(){
    cin&gt;&gt;l&gt;&gt;r;
    --l;
    init();//找出所有&quot;幸运号码&quot;
    work();
}
</code></pre>
</div></div></div><div class="mdui-row-xs-3 article"><div class="mdui-col"><a href="/posts/划分dp/" class="text" id='pre_button'><i class="mdui-icon material-icons">arrow_back</i>划分dp</a></div><div class="mdui-col mdui-text-center">容斥与二项式反演</div><div class="mdui-col"><a href="/posts/csp-s-2019-游记/" class="text mdui-float-right" id='nxt_button'>csp-s-2019-游记<i class="mdui-icon material-icons">arrow_forward</i></a></div></div><div class="mdui-card" style="margin-top: 50px;"><div class="mdui-card-primary"><div class="mdui-card-primary-title"><i class="mdui-icon material-icons">comment</i>评论</div></div><div class="mdui-card-content" id='comments'><center><div class="mdui-spinner"></div></center></div></div><script>
function SetComment(){
    window.comment=new Valine({
        el: '#comments',
        placeholder: "说几句嘛qwq",
        appId: "NLh0fhLRvD8gOWEC3vtOIRx5-gzGzoHsz",
        appKey: "DSwqdjPFKAnO4CFMQypfkcB9",
        path: window.location.pathname,
    });
}
function GenComment(){
    document.getElementById('comments').innerHTML=`<center><div class="mdui-spinner mdui-spinner-colorful"></div></center>`;
    mdui.mutation(document.getElementById('comments'));

    if(document.getElementById("comment_js"))SetComment();
    else{
        var valinejs=document.createElement('script');
        valinejs.id="comment_js";
        valinejs.src="https://cdn.jsdelivr.net/gh/xCss/Valine/dist/Valine.min.js";
        valinejs.async=true;
        valinejs.onload=SetComment;
    }
    document.getElementsByTagName("head")[0].appendChild(valinejs);
}
</script></div><div class="mdui-drawer mdui-drawer-close" id="drawer"><ul class="mdui-list"><li class='mdui-subheader'>Pages</li><li class="mdui-list-item"><i class="mdui-list-item-icon mdui-icon material-icons"">bookmark_border</i><a href="/tags/" target="_blank" rel="noopener" class="mdui-list-item-content">标签云</a></li><li class="mdui-list-item"><i class="mdui-list-item-icon mdui-icon material-icons"">book</i><a href="/categories/" target="_blank" rel="noopener" class="mdui-list-item-content">分类</a></li><li class="mdui-list-item"><i class="mdui-list-item-icon mdui-icon material-icons"">link</i><a href="/links/" target="_blank" rel="noopener" class="mdui-list-item-content">友链</a></li><li class="mdui-list-item"><i class="mdui-list-item-icon mdui-icon material-icons"">build</i><a href="/tools/" target="_blank" rel="noopener" class="mdui-list-item-content">工具集</a></li><li class="mdui-list-item"><i class="mdui-list-item-icon mdui-icon material-icons"">person</i><a href="/about/" target="_blank" rel="noopener" class="mdui-list-item-content">关于我</a></li><li class="mdui-list-item"><i class="mdui-list-item-icon mdui-icon material-icons"">rss_feed</i><a href="/atom.xml" target="_blank" rel="noopener" class="mdui-list-item-content">订阅</a></li><li class="mdui-list-item"><i class="mdui-list-item-icon mdui-icon material-icons"">list</i><a href="/sitemap.xml" target="_blank" rel="noopener" class="mdui-list-item-content">站点地图</a></li><li class="mdui-list-item"><i class="mdui-list-item-icon mdui-icon material-icons"">comment</i><a href="https://nlh0fhlrsgij.leanapp.cn/" target="_blank" rel="noopener" class="mdui-list-item-content">评论管理</a></li><li class='mdui-subheader'>Catch me</li><li class="mdui-list-item"><i class="mdui-list-item-icon mdui-icon material-icons"style='color:dodgerblue'">email</i><a href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=fwUcIBIWEhY-Dg5RHBAS" target="_blank" rel="noopener" class="mdui-list-item-content">给我写信</a></li><li class="mdui-list-item"><i class="mdui-list-item-icon mdui-icon mqii mqii-telegram"style='color:#66ccff'"></i><a href="https://t.me/zcmimi/" target="_blank" rel="noopener" class="mdui-list-item-content">电报</a></li><li class="mdui-list-item"><i class="mdui-list-item-icon mdui-icon mqii mqii-twitter"style='color:rgba(29,161,242,1.00)'"></i><a href="https://twitter.com/zc_mimi/" target="_blank" rel="noopener" class="mdui-list-item-content">推特</a></li><li class="mdui-list-item"><i class="mdui-list-item-icon mdui-icon mqii mqii-bilibili"style='color:#F06292'"></i><a href="https://space.bilibili.com/110897068/" target="_blank" rel="noopener" class="mdui-list-item-content">哔哩哔哩</a></li><li class="mdui-list-item"><i class="mdui-list-item-icon mdui-icon mqii mqii-netease-cloud-music"style='color:red'"></i><a href="https://music.163.com/user/home/?id=507163653" target="_blank" rel="noopener" class="mdui-list-item-content">网易云音乐</a></li><li class="mdui-list-item"><i class="mdui-list-item-icon mdui-icon mqii mqii-zhihu"style='color:#0084ff'"></i><a href="https://www.zhihu.com/people/zcmimi/" target="_blank" rel="noopener" class="mdui-list-item-content">知乎</a></li><li class="mdui-list-item"><i class="mdui-list-item-icon mdui-icon mqii mqii-github""></i><a href="https://github.com/zcmimi/" target="_blank" rel="noopener" class="mdui-list-item-content">Github</a></li><li class='mdui-subheader'>Links</li><li class="mdui-list-item"><img class="mdui-list-item-icon" src="https://cdn.jsdelivr.net/gh/zcmimi/cdn@master/avatar/avatar64x64.webp" alt><a href="https://zcmimi.top/" target="_blank" rel="noopener" class="mdui-list-item-content">index</a></li><li class="mdui-list-item"><i class="mdui-list-item-icon mdui-icon mqii mqii-telegram"style='color:#bbb'"></i><a href="https://travellings.now.sh/" target="_blank" rel="noopener" class="mdui-list-item-content">Traveling</a></li></ul></div><div class="mdui-drawer mdui-drawer-close mdui-drawer-right" id="toc_drawer" hidden><ul class="mdui-list" id="toc"></ul></div></body><button class="mdui-fab mdui-fab-mini mdui-fab-fixed mdui-fab-hide" id="totop" onclick="totop()" style="z-index: 99999;"><i class="mdui-icon material-icons">keyboard_arrow_up</i></button><footer class="mdui-m-t-5"><div class="mdui-card"><div class="mdui-card-content mdui-p-a-5"><div class="mdui-container"><div class="mdui-row-sm-3"><div class="mdui-col"><div class="mdui-row"><div class="mdui-col-xs-2 mdui-col-sm-1 mdui-col-md-1" style="margin: 10px;"><a href="https://github.com/zcmimi/" target="_blank" rel="noopener"><i class="mdui-icon mqii mqii-github"></i></a></div><div class="mdui-col-xs-2 mdui-col-sm-1 mdui-col-md-1" style="margin: 10px;"><a href="https://space.bilibili.com/110897068/" target="_blank" rel="noopener"><i class="mdui-icon mqii mqii-bilibili"></i></a></div><div class="mdui-col-xs-2 mdui-col-sm-1 mdui-col-md-1" style="margin: 10px;"><a href="https://www.zhihu.com/people/zcmimi/" target="_blank" rel="noopener"><i class="mdui-icon mqii mqii-zhihu"></i></a></div><div class="mdui-col-xs-2 mdui-col-sm-1 mdui-col-md-1" style="margin: 10px;"><a href="https://twitter.com/zc_mimi/" target="_blank" rel="noopener"><i class="mdui-icon mqii mqii-twitter"></i></a></div></div></div><div class="mdui-col mdui-text-center"><span>Copyright ©&nbsp;2019-2020&nbsp;zcmimi's blog</span></div><div class="mdui-col mdui-text-center mdui-typo"><div>Powered by<a href="https://github.com/zcmimi/py-blog" target="_blank" rel="noopener">py-blog</a></div><div>Theme<a href="https://github.com/zcmimi/py-blog-theme-material" target="_blank" rel="noopener">material</a></div></div></div></div></div></div></footer><div class="mdui-dialog" id="search_dialog" style="min-height: 50%;"><div class="mdui-dialog-title">Search</div><div class="mdui-dialog-content"><div class="mdui-textfield"><i class="mdui-icon material-icons">search</i><input id="search_input" class="mdui-textfield-input" placeholder="搜索"></div><div id="search_result" class="mdui-list"></div></div></div><script async src='/assets/serverless_search.js'></script><script>document.getElementById('search_input').onchange=function(){search("https://search.blog.zcmimi.top");}</script><script async defer src="/assets/mdui/js/mdui.min.js"></script><script async defer src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/highlight.min.js"></script><script async defer src="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.js"></script><script defer src='/assets/bundle.min.js'></script><script defer src='/custom.js'></script><script defer>
var pjaxjs=document.createElement("script");
pjaxjs.src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js";pjaxjs.async=true;
pjaxjs.onload=()=>{
    var pjax=new Pjax({elements:"a",selectors:["title","#TOC",".mdui-container",".js-pjax"]});
    document.addEventListener('pjax:send',()=>{document.getElementById('loading-progress').hidden=0;});
    document.addEventListener('pjax:complete',()=>{document.getElementById('loading-progress').hidden=1;pjax_load();});
}
document.getElementsByTagName("head")[0].append(pjaxjs);
</script><script defer>
window.addEventListener('load',()=>{try{GenComment();}catch{}});
document.addEventListener('pjax:complete',()=>{try{GenComment();}catch{}});
</script></html>